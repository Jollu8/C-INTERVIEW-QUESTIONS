### Более эффективный C++

1. Тщательно различайте указатели и ссылки (когда вы знаете, что вам нужно указать на что-то и никогда не менять
   указание на другие вещи, или когда вы реализуете оператор, требования к синтаксису которого не могут быть выполнены
   указателями, вы должны выбирать ссылки; В любое другое время используйте указатели)
2. Лучше всего использовать операторы приведения типов
   C++ (`static_cast`, `const_cast`, `dynamic_cast`, `reinterpret_cast`)
3. Никогда не обрабатывайте массивы полиморфно (полиморфизм и арифметика указателей не могут быть смешаны; объекты
   массива почти всегда включают арифметику указателей, поэтому массивы и полиморфизм не должны смешиваться)
4. Не предоставляйте конструктор по умолчанию, если это необходимо (чтобы избежать бессмысленной инициализации полей в
   объекте)
5. Будьте настороже с пользовательскими "функциями преобразования типов" (конструкторы с одним аргументом можно избежать
   простыми методами (ключевые слова explicit) или прокси-классами); неявные операторы преобразования типов можно
   изменить на явные член-функции, чтобы избежать неожиданного поведения)
6. Различайте префиксные и постфиксные формы оператора инкремента/декремента (предварительно накапливайте и выдавайте
   ссылку; после подготовки принимайте, и накапливайте, и возвращайте const объект; при обработке пользовательских типов
   следует использовать предварительный инкремент как можно больше; пост-реализация должна основываться на его
   пред-брате)
7. Никогда не перегружайте операторы `&&`, `||` и `,` (перегрузка `&&` и `||` заменит "внезапно-семантическую семантику"
   на "семантику вызова функции"; перегрузка `,` не гарантирует, что левое выражение должно быть оценено раньше, чем
   правое выражение)
8. Понимайте различные значения new и
   delete (`new operator`, `operator new`, `placement new`, `operator new[]`; `delete operator`, `operator delete`, `destructor`, `operator delete[]`)
9. Используйте деструкторы, чтобы избежать утечки ресурсов (освобождение ресурсов при деструкторах может предотвратить
   утечки ресурсов во время исключений)
10. Предотвращайте утечки ресурсов в конструкторах (поскольку C++ будет деструктурировать только уже сконструированные
    объекты, конструктор может использовать try...catch или auto_ptr (и подобные классы) для обработки утечек ресурсов
    при возникновении исключений)
11. Запрещайте исключениям вытекать из деструкторов (причина: во-первых, избегайте вызова функции terminate в механизме
    размотки стека при распространении исключений; во-вторых, помогите обеспечить, чтобы деструкторы завершили все, что
    они должны сделать)
12. Понимайте разницу между "бросанием исключения" и "передачей параметра" или "вызовом виртуальной функции" (во-первых,
    объекты исключений всегда копируются (кроме указателя), если вы ловите даже по значению, он копируется дважды, но
    объект, переданный в параметр функции, не обязательно должен быть скопирован. Во-вторых, у объекта, который "
    бросается как исключения", меньше разрешенных действий преобразования типа, чем у объекта, "переданного в функцию";
    в-третьих, catch-клаузу проверяет компилятор на ее "порядок, в котором она появляется в исходном коде". Первое
    совпадение удается и выполняется, и вызывается виртуальная функция. Функция")
13. Захватывайте исключения по ссылке (чтобы избежать проблемы удаления объекта и обрезания объектов исключений,
    сохраните возможность ловить стандартные исключения и ограничьте количество раз, когда объект исключения должен быть
    скопирован)
14. Мудро используйте спецификации исключений (спецификации исключений предоставляют отличное описание того, какие
    исключения функция ожидает бросить; есть также некоторые недостатки, включая то, что компилятор проверяет их только
    локально и легко непреднамеренно нарушает их. Предотвращайте обработку неожиданных исключений обработчиками
    исключений более высокого уровня)
15. Понимайте стоимость обработки исключений (грубо оценивая, если используется блок try, общий код расширится примерно на 5% -10%, и скорость выполнения также уменьшится на это число; поэтому, пожалуйста, ограничьте использование блока try и спецификации исключений до мест, где они обязательно должны использоваться, и бросайте исключения только в случае реальных исключений)
16. Имейте в виду правило 80-20 (общая производительность программного обеспечения почти всегда определяется небольшой частью его составных элементов (кодов), и код, который потребляет ресурсы, можно определить с помощью профилировщика программы)
17. Рассмотрите возможность использования ленивой оценки (можно применить к: подсчету ссылок для избежания ненужного копирования объектов, различиям между операциями чтения и записи оператора [] для выполнения разных действий, ленивой выборке (удаление) для избежания ненужного чтения базы данных, и ленивой оценке выражений (чтобы избежать ненужных числовых вычислений)
18. Распределите ожидаемую вычислительную стоимость (когда вы должны поддерживать определенные операции, структура которых почти всегда требуется, или когда результаты часто требуются несколько раз, чрезмерная оценка может улучшить эффективность программы)

### Руководство по стилю Google C++

* Английский: [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html)

### Другое

* [FAQ Бьярна Страуструпа](http://www.stroustrup.com/bs_faq.html)
* [FAQ по стилю и трюкам C++ для Бьярна Страуструпа](http://www.stroustrup.com/bs_faq2.html)