## <span style="color:red">*Разница и связь между виртуальными функциями и чисто виртуальными функциями в C++*</span>
В C++ виртуальные функции и чисто `(pure)` виртуальные функции отличаются следующим образом:

1. Если в классе объявлена виртуальная функция, эта функция реализована, даже если это пустая реализация. Её задача -
   позволить эту функцию быть переопределенной в его подклассах, таким образом, компилятор может использовать позднее
   связывание для достижения полиморфизма. Чисто виртуальная функция - это просто интерфейс, это только объявление
   функции, его реализация должна быть в подклассах.

2. Виртуальная функция в подклассе может не быть переопределена; но чисто виртуальная функция должна быть реализована в
   подклассе, это похоже на интерфейс в Java. Обычно добавление `virtual` к большому количеству функций считается
   хорошей практикой, хотя это и ухудшает производительность, но увеличивает полиморфность объектно-ориентированного
   программирования, потому что трудно предсказать, не будет ли функция в родительском классе изменена в подклассе.

3. Класс с виртуальной функцией используется для "реализации наследования", наследуя интерфейс и одновременно реализацию
   родительского класса. Конечно, вы также можете завершить свою собственную реализацию. Чисто виртуальная функция
   фокусируется на единообразии интерфейса, реализация выполняется подклассами.

4. Класс с чисто виртуальной функцией называется виртуальным базовым классом, такой базовый класс не может напрямую
   создавать объекты, он может быть использован только при наследовании и переопределении его виртуальных функций. Такой
   класс также называется абстрактным классом. Абстрактный класс и обычно упоминаемый виртуальный базовый класс
   отличаются, в C# для определения абстрактного класса используется `abstract`, а в C++ есть понятие абстрактного
   класса, но нет такого ключевого слова. После наследования абстрактного класса подкласс может продолжать быть
   абстрактным классом, или может быть обычным классом, а виртуальный базовый класс, который содержит чисто виртуальные
   функции, если он наследуется, то подкласс должен реализовать все чисто виртуальные функции в виртуальном базовом
   классе, его подкласс не может быть абстрактным классом.

Чисто виртуальная функция
Класс, объявивший чисто виртуальную функцию, является абстрактным классом. Поэтому пользователи не могут создавать
экземпляры класса, они могут создавать только экземпляры его подклассов. Наиболее заметной особенностью чисто
виртуальных функций является то, что они должны быть заново объявлены в классе наследнике (без `=0` в конце, иначе этот
подкласс тоже не может быть инстанцирован), и они часто не имеют определения в абстрактном классе. Цель определения
чисто виртуальной функции - заставить подклассы наследовать только интерфейс функции. Смысл чисто виртуальной функции
заключается в том, что все объекты класса (в основном объекты подкласса) могут выполнять действия чисто виртуальной
функции, но класс не может предоставить разумную реализацию по умолчанию для чисто виртуальной функции. Поэтому
объявление чисто виртуальной функции класса говорит дизайнеру подкласса: "Вы должны предоставить реализацию чисто
виртуальной функции, но я не знаю, как вы ее реализуете". Кстати, определение чисто виртуальной функции также возможно.
То есть вы можете предоставить реализацию для чисто виртуальной функции, компилятор C++ не будет препятствовать этому (
компилятор DEV_CPP G++ (gcc 3.4.2) не поддерживает определение поведения по умолчанию для чисто виртуальной функции; в
VC6.0 поддерживается определение поведения по умолчанию для чисто виртуальной функции, виртуальная функция подкласса
переопределяет чисто виртуальную функцию базового класса), но единственный способ вызвать его - полностью указать имя
класса, который вызывает его (например, `pb->Base:: pureVirtual()`). Иногда объявление класса, который не содержит
ничего, кроме чисто виртуальной функции, бывает полезным. Такой класс называется классом протокола (Protocol class), он
предоставляет подклассам только интерфейс функции, не имея вообще никакой реализации.

Виртуальная функция (здесь подразумевается не чисто виртуальная функция)
Ситуация с виртуальной функцией немного отличается от чисто виртуальной функции. Как правило, подкласс наследует
интерфейс функции, но простая виртуальная функция обычно также предоставляет реализацию, подкласс может выбрать
переопределение (override) или не переопределять их. Цель объявления виртуальной функции - заставить подкласс
наследовать интерфейс функции и реализацию по умолчанию. Смысл виртуальной функции заключается в том, что каждый класс
должен предоставить виртуальную функцию, которую можно вызвать, но каждый класс может обрабатывать ее любым способом,
который они считают подходящим. Если некоторый класс не хочет делать что-то особенное, он может использовать функцию
обработки по умолчанию, предоставленную в базовом классе. То есть объявление виртуальной функции говорит дизайнеру
подкласса: "Вы должны поддерживать виртуальную функцию, но если вы не хотите писать свою версию, вы можете использовать
версию по умолчанию в базовом классе". На самом деле, предоставление объявления функции и реализации по умолчанию для в