## <span style="color:red">*〽️ Дата Структуры*</span>
> Раздел "Структуры данных" (DS) требует визуализации для наглядного представления. Нужна ваша помощь. :)

### Структура последовательности

#### Последовательный стек (Sequence Stack)

[//]: # (todo)
[SqStack.cpp](DataStructure/SqStack.cpp)

[//]: # (Структуры данных и изображения последовательного стека)

```c++
typedef struct {
	ElemType *elem;
	int top;
	int size;
	int increment;
} SqStack;
```

#### Очередь (Sequence Queue)

Структура данных очереди

```c++
typedef struct {
	ElemType * elem;
	int front;
	int rear;
	int maxSize;
}SqQueue;
```

##### Ациклическая очередь

[//]: # (Изображение ациклической очереди)

`SqQueue.rear++`

##### Циклическая очередь

[//]: # (Изображение циклической очереди)

`SqQueue.rear = (SqQueue.rear + 1) % SqQueue.maxSize`

#### Последовательная таблица (Sequence List)

[//]: # (todo)
[SqList.cpp](DataStructure/SqList.cpp)

[//]: # (Структура данных и изображения последовательной таблицы)

```c++
typedef struct {
	ElemType *elem;
	int length;
	int size;
	int increment;
} SqList;
```
### Структура цепочки

[LinkList.cpp](DataStructure/LinkList.cpp)

[LinkList_with_head.cpp](DataStructure/LinkList_with_head.cpp)

Структура данных цепочки

```c++
typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList; 
```

#### Цепочная очередь (Link Queue)

[//]: # (Изображение цепочной очереди)

#### Цепочное представление линейного списка

##### Односвязный список (Link List)

[//]: # (Изображение односвязного списка)

##### Двусвязный список (Du-Link-List)

[//]: # (Изображение двусвязного списка)

##### Циклический связанный список (Cir-Link-List)

[//]: # (Изображение циклического связанного списка)

### Хеш-таблица

[HashTable.cpp](DataStructure/HashTable.cpp)

#### Понятие

Хеш-функция: `H(key): K -> D , key ∈ K`

#### Метод построения

* Прямое адресование
* Метод деления с остатком
* Метод цифрового анализа
* Метод свертки
* Метод квадратов

#### Метод разрешения коллизий

* Метод цепочных адресов: односвязный список, связанный с одинаковым ключом
* Открытое адресование
  * Линейный метод обнаружения: одинаковый ключ -> поместить в следующую позицию ключа, `Hi = (H(key) + i) % m`
  * Вторичный метод обнаружения: одинаковый ключ -> поместить в `Di = 1^2, -1^2, ..., ±（k)^2,(k<=m/2）`
  * Случайное обнаружение: `H = (H(key) + псевдослучайное число) % m`

#### Структура данных хеш-таблицы для линейного пробирования

[//]: # (Структура данных хеш-таблицы и изображения для линейного обнаружения)

```c++
typedef char KeyType;

typedef struct {
	KeyType key;
}RcdType;

typedef struct {
	RcdType *rcd;
	int size;
	int count;
	bool *tag;
}HashTable;
```

### Рекурсия

#### Понятие

Функция вызывает сама себя напрямую или косвенно

#### Рекурсия и разделение

* Разделение и завоевание
  * Разбиение проблемы
  * Размер декомпозиции проблемы
* Половинный поиск (рекурсивный)
* Сортировка слиянием (рекурсивная)
* Быстрая сортировка (рекурсивная)

#### Рекурсия и итерация

* Итерация: использование старого значения переменной для выведения нового значения
* Половинный поиск (итеративный)
* Сортировка слиянием (итеративная)

#### Обобщенная таблица

##### Представление хранения в виде списка с головой и хвостом

Представления хранения в виде списка с головой и хвостом и изображения для обобщенных таблиц

```c++
// Представление хранения в виде списка с головой и хвостом обобщенного списка
typedef enum {ATOM, LIST} ElemTag;
// ATOM == 0: атом, LIST == 1: дочерняя таблица
typedef struct GLNode {
    ElemTag tag;
    // общая часть, используемая для различения атомарных узлов от узлов таблицы
    union {
        // общая часть атомарного узла и узла таблицы
        AtomType atom;
         // атом - это диапазон атомарных узлов, AtomType определяется пользователем
        struct {
            struct GLNode *hp, *tp;
        } ptr;
        /// ptr - это поле указателя узла таблицы, prt.hp и ptr.tp указывают на заголовок таблицы и хвост таблицы соответственно
    } a;
} *GList, GLNode;
```

##### Расширенное линейное связное представление списка

[//]: # (Расширенные линейные связные представления и изображения списков todo)

```c++
// Расширенное линейное связное представление обобщенных таблиц
typedef enum {ATOM, LIST} ElemTag;
// ATOM == 0: атом, LIST == 1: дочерняя таблица
typedef struct GLNode1 {
    ElemTag tag;
    // общая часть, используется для различия атомарных узлов от узлов таблицы
    union {
        // совместная часть атомарного узла и узла таблицы
        AtomType atom;  // диапазон атомарных узлов
        struct GLNode1 *hp; // указатель указателя таблицы
    } a;
    struct GLNode1 *tp;
    // Эквивалент next линейного связного списка, указывающий на следующий 
} *GList1, GLNode1;
```

### Бинарное дерево

[//]: # (todo)
[BinaryTree.cpp](DataStructure/BinaryTree.cpp)

#### Свойства

1. До 2<sup>(i-1)</sup> узлов на i-м уровне непустого бинарного дерева (i> = 1)
2. Бинарное дерево с глубиной k до 2<sup>k</sup>-1 узла (k >= 1)
3. Количество узлов с степенью 0 равно n<sub>0</sub>, и количество узлов со степенью 2 равно n<sub>2</sub>, тогда n<sub>0</sub> = n<sub>2</sub> + 1
4. Глубина полного бинарного дерева с n узлами k = ⌊ log <sub> 2 </ sub> (n) ⌋ + 1
5. Для узла с номером i (1 <= i <= n) в полном бинарном дереве с n узлами
  1. Если i = 1, это корень, иначе родители равны ⌊ i / 2 ⌋
  2. Если 2i > n, у узла i нет левого ребенка, иначе номер ребенка равен 2i
  3. Если 2i + 1> n, у узла i нет правого ребенка, иначе номер ребенка равен 2i + 1

#### Структура хранения

Структура данных бинарного дерева

```cpp
typedef struct BiTNode
{
    TElemType data;
    struct BiTNode *lchild, *rchild;
}BiTNode, *BiTree;
```

##### Последовательное хранение

[//]: # (Изображения последовательного хранения бинарного дерева todo)

##### Цепное хранение

[//]: # (Изображения цепного хранения бинарного дерева todo) 

#### Обход

* Последовательный обход
* Обход в порядке
* Последующие обходы
* Иерархический обход

#### Категории

* Полное бинарное дерево
* Полное бинарное дерево (куча)
  * Большая вершина кучи: корень> = левый && корень> = правый
  * Маленькая вершина кучи: корень <= левый && корень <= правый
* Бинарное дерево поиска (бинарное дерево сортировки): левый <корень <правый
* Сбалансированное бинарное дерево (дерево AVL): | Высота левого поддерева-Высота правого поддерева | <= 1
* Наименее несбалансированное дерево: Вставка новых узлов в сбалансированное бинарное дерево вызывает несбалансированное поддерево: Регулировка:
  * Тип LL: левый ребенок корня
  * Тип RR: правый ребенок корня
  * Тип LR: Левый ребенок корня, левый
  * Тип RL: Левый ребенок правого ребенка, сначала повернуть вправо, затем влево

### Другие деревья и леса

#### Структура хранения дерева

* Родительская нотация
* Родительская нотация
* Нотация ребенка-брата

#### И проверка

Набор непересекающихся подмножеств S = {S1, S2, ..., Sn}

#### Сбалансированное бинарное дерево (дерево AVL)

##### Природа

* | Высота левого поддерева дерева-Высота правого поддерева дерева | <= 1
* Сбалансированное бинарное дерево должно быть бинарным деревом поиска, иначе это не обязательно
* Формула узлов минимального бинарного сбалансированного дерева: `F(n) = F(n-1) + F(n-2) + 1` (1 - это корневой узел, F (n-1) - это количество узлов левого поддерева, F (n-2) - это количество узлов в правом поддереве)

[//]: # (Изображения сбалансированного бинарного дерева todo)



