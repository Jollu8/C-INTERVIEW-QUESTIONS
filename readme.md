# ВОПРОСЫ НА СОБЕСЕДОВАНИИ ПО С++

- Дорогой мой читатель, я, как и вы, когда-то был начинающим или Буду как вы опытным программистом на C++. В интернете
  очень много информации,
  но тяжело найти именно то, что нужно. Случайно я увидел 400 вопросов для разработчика на C++ и у меня появилось
  желание создать небольшой гайд-шпаргалку на русском языке. На самом деле, я сделал этот гайд для себя, чтобы
  подготовиться к собеседованию. Когда я писал этот монолог, у меня уже были готовые вопросы и ответы для уровня junior.
  Дорогой мой читатель, если у вас есть хорошая идея или вы хотите внести свой вклад, пожалуйста, не стесняйтесь и
  пишите мне в телеграм @LordJollu. Я постараюсь помочь. Кстати, у меня есть еще
  сборник [алгоритмов](https://github.com/Jollu8/Algorithms) на языке C++ и
  Яндекс контест алгоритмы на языке C++. Желаю вам удачи в поиске работы! С Уважением, Джолу

|     |      Важно      |                  Ответы                   |
|:---:|:------------------:|:-----------------------------------------:|
|  a  | Как запустить код? | выберите нунжную конфигурацию и запустите |
|  b  |   Неверный ответ   |           Пишите мне в телеграм           |
|  c  |     GCC, Clang     |           GCC::12+, Clang::14++           |

- ## [1.Junior](./junior.md)

1. Общие вопросы
2. Мета программирование
3. Препроцессор и компиляция
4. Язык C
5. c++ OOP
6. STL / Algorithms
7. Multithreading
8. Networking
9. OS / Linux
10. SCM / CI / CD
11. Practise tasks

---

- ## [2.Middle](./middle.md)

1. Общее
2. Препроцессор и компиляция
3. C
4. C++
5. Паттерны проектирования
6. Метапрограммирование
7. OOP/OOD
8. STL/Algorithms
9. Многопоточность
10. Networking
11. SCM/CI/CD
12. Практические задачи

---

- ## [3.Senior](./senior.md)

- ## Эффективный C++

1. Рассматривайте C++ как федерацию языков (C, Object-Oriented C++, Template C++, STL).
2. Позвольте компилятору заменить препроцессор (по возможности замените #define на const, enum, inline).
3. Используйте const как можно чаще.

4. Убедитесь, что объекты инициализированы перед использованием (инициализация при конструировании (конструктор
   копирования) эффективнее, чем инициализация после конструирования по умолчанию (оператор присваивания копирования)).

5. Знайте, какие функции C++ автоматически создает и вызывает компилятор (компилятор автоматически создает конструктор
   по умолчанию, конструктор копирования, оператор присваивания копирования и деструктор для класса).

6. Если вы не хотите использовать функции, автоматически созданные компилятором, явно откажитесь от них (объявите
   нежелательные функции-члены как private и не реализуйте их).

7. Объявляйте виртуальный деструктор для полиморфных базовых классов (если класс имеет хотя бы одну виртуальную функцию,
   он должен иметь виртуальный деструктор).

8. Не позволяйте исключениям покидать деструктор (деструктор должен поглощать исключения и не распространять их или
   завершать программу, а не выбрасывать исключения; если нужно обработать исключения, это должно делаться в обычных
   функциях, а не в деструкторе).

9. Никогда не вызывайте виртуальные функции в конструкторе или деструкторе (такие вызовы никогда не опускаются до
   производного класса).

10. Оператор = должен возвращать ссылку на *this (для цепочечного присваивания).

11. Обрабатывайте “самоприсваивание” в операторе =.
12. Вот перевод текста на русский язык с примерами:

13. Управляйте ресурсами с помощью объектов (ресурсы получаются в конструкторе и освобождаются в деструкторе.
    Рекомендуется использовать интеллектуальные указатели. Момент получения ресурса — это момент инициализации (Resource
    Acquisition Is Initialization, RAII)).
14. Будьте осторожны с поведением копирования в классах управления ресурсами (обычное поведение копирования класса RAII:
    подавление копирования, подсчет ссылок, глубокое копирование, передача прав собственности на нижний ресурс (
    аналогично auto_ptr)).

15. Предоставлять доступ к необработанным ресурсам в классе управления ресурсами (доступ к необработанным ресурсам может
    быть явно преобразован или неявно преобразован, вообще говоря, явное преобразование безопаснее, а неявное
    преобразование удобнее для клиентов).

16. Используйте ту же форму при использовании новых и удаленных в парах ( если new используется в [] середине delete []
    и new если не используется в [] середине delete).

17. Сохраните (поместите) новый объект в интеллектуальный указатель в отдельном выражении (в противном случае это может
    привести к незаметным утечкам ресурсов из-за оптимизации компилятора).

18. Сделайте интерфейс легким для правильного использования и непростым для неправильного использования (методы
    содействия нормальному использованию: согласованность интерфейсов, совместимое поведение встроенных типов; методы
    предотвращения неправильного использования: создавать новые типы, ограничивать операции над типами, ограничивать
    значения объектов , устранить обязанности Заказчика по управлению ресурсами).

19. Разработка класса аналогична разработке типа: необходимо учитывать создание, уничтожение, инициализацию,
    присваивание, передачу значения, юридическое значение, отношение наследования, преобразование, обобщение и т. д.

20. Скорее замените передачу по значению на передачу по ссылке на константу (первая обычно более эффективна и позволяет
    избежать проблем с нарезкой, но не работает со встроенными типами, итераторами STL, функциональными объектами).

21. Когда вы должны вернуть объект, не пытайтесь вернуть его ссылку (никогда не возвращайте указатель или ссылку,
    указывающую на локальный объект стека, или возвращайте ссылку на объект, размещенный в куче, или возвращайте
    указатель, или ссылку на локальный объект). статический объект и может потребоваться несколько таких объектов.)

22. Объявить переменные-члены как частные (для инкапсуляции, согласованности, точного контроля над их чтением и записью
    и т. д.)

23. Скорее замените функции-члены функциями, не являющимися членами и не являющимися друзьями (улучшая инкапсуляцию,
    гибкость упаковки и функциональную масштабируемость).

24. Если все параметры (включая метафорический параметр, на который указывает указатель this) требуют преобразования
    типов, используйте для этого функции, не являющиеся членами.

25. Рассмотрите возможность написания функции подкачки, которая не генерирует исключений.

26. максимально задержать появление определений переменных (увеличивает ясность программы и повышает ее эффективность)

27. Старайтесь делать как можно меньше действий преобразования (старый стиль: (T)expression, T(expression); новый стиль:
    const_cast<T>(expression), dynamic_cast<T>(expression), , reinterpret_cast<T>(expression), static_cast<T>(
    expression),; старайтесь избегать преобразования, сосредоточьтесь на эффективности и избегайте dynamic_casts,
    старайтесь проектировать без преобразования, вы можете инкапсулировать преобразование в функцию, скорее используйте
    новое преобразование)

28. Избегайте использования дескрипторов (включая ссылки, указатели и итераторы) для указания внутри объектов (чтобы
    усилить инкапсуляцию, заставить константные функции-члены вести себя как константные и уменьшить вероятность
    «висячих дескрипторов» (таких как висячие указатели и т. д.))
29. Тщательно изучите все тонкости встраивания (встраивание — это поведение во время компиляции в большинстве программ
    на C++; действительно ли встроенная функция является встроенной, зависит от компилятора; большинство компиляторов
    отклоняют слишком сложные функции (например, с циклами или рекурсией) для встраивания, а все вызовы виртуальных
    функций (кроме самых простых) также не будут встроены; увеличение кода, вызванное встраиванием, может привести к
    потере эффективности; встроенные функции нельзя обновить с помощью обновлений библиотеки).
30. Минимизируйте зависимости компиляции между файлами (если вы можете использовать ссылки на объекты или указатели на
    объекты для выполнения задачи, не используйте объекты; если можете, попробуйте заменить определение класса
    объявлением класса; предоставьте разницу между объявлением и заголовочным файлом определения).
31. Убедитесь, что ваше общедоступное наследование формирует отношение is-a (является) (все, что относится к базовым
    классам, должно применяться к производным классам, потому что каждый объект производного класса также является
    объектом базового класса).
32. Избегайте затенения унаследованных имен (вы можете использовать объявления using или функции пересылки (forwarding
    functions), чтобы затененные имена снова увидели свет).
33. Различайте наследование интерфейса и наследование реализации (при общедоступном наследовании производные классы
    всегда наследуют интерфейс базового класса; чистые виртуальные функции определяют только наследование интерфейса;
    нечистые виртуальные функции определяют наследование интерфейса и наследование реализации по умолчанию;
    невиртуальные функции определяют наследование интерфейса и обязательное наследование реализации).

34. Рассмотрите альтернативы виртуальным функциям (например, метод невиртуального интерфейса (NVI) шаблона
    проектирования Template Method, замените виртуальные функции «переменными-членами указателя на функцию», замените
    виртуальные функции переменными-членами и замените виртуальные функции в системе наследования tr1::function.
    является виртуальной функцией в другой иерархии наследования).

35. Никогда не переопределяйте унаследованные невиртуальные функции.

36. Никогда не переопределяйте унаследованные значения параметров по умолчанию, потому что значения параметров по
    умолчанию связаны статически (statically bound), а виртуальные функции связаны динамически (динамически связаны).

37. С помощью составления формируйте отношения has-a (имеет) или «реализуется согласно чему-то» (в прикладной области
    составное средство имеет-a (имеет одно); в области реализации составное средство -реализовано-с точки зрения-из (
    реализовано в терминах)).

38. Разумно и осторожно используйте частное наследование (частное наследование означает "реализовано-в-терминах-из" (
    реализовано в соответствии с чем-то), используйте композицию, когда это возможно, когда производному классу
    требуется доступ к членам защищенного базового класса или необходимо переопределить наследование. приходит
    виртуальная функция, или когда требуется пустая базовая оптимизация, используется приватное наследование).

39. Разумно и осторожно используйте множественное наследование (множественное наследование сложнее, чем одиночное
    наследование, может привести к новым неоднозначностям и необходимости виртуального наследования, но имеет законное
    использование, например, «общедоступный наследует класс интерфейса» и «частный наследует класс». для помощи в
    реализации»; виртуальное наследование может решить проблему неоднозначности алмазного наследования при множественном
    наследовании, но это увеличит стоимость размера, скорости, инициализации и сложности присваивания и т. д.).

40. Понимайте неявные интерфейсы и полиморфизм времени компиляции (классы и шаблоны поддерживают интерфейсы (interfaces)
    и полиморфизм (polymorphism); интерфейсы класса являются явными (explicit) и основаны на подписи, а полиморфизм
    происходит через виртуальные функции во время выполнения; интерфейсы шаблона являются неявными (implicit) и основаны
    на действительных выражениях, а полиморфизм происходит через конкретизацию шаблона и разрешение перегрузки функций (
    function overloading resolution) во время компиляции).

41. Понимайте двойное значение typename (при объявлении параметра типа шаблона ключевые слова class и typename имеют
    абсолютно одинаковое значение; используйте ключевое слово typename для обозначения вложенных зависимых типовых имён,
    но не используйте его как модификатор базового класса в списках базовых классов или списках инициализации членов).

42. Изучите обработку имён в шаблонизированных базовых классах (в шаблонах производных классах можно ссылаться на члены
    шаблонных базовых классов через this-> или с помощью явного «квалификатора квалификации базового класса»).

43. Выделите код, не зависящий от параметров, из шаблонов (раздутие кода из-за параметров типа (non-type template
    parameters) часто можно устранить путем замены параметров шаблона параметрами функций или переменными-членами
    класса; раздутие кода из-за параметров типа (type parameters) часто можно устранить путем общего использования кода
    реализации типами реализации (instantiation types) с одинаковым бинарным представлением).
44. Используйте шаблоны функций-членов для принятия всех совместимых типов (используйте шаблоны функций-членов для
    создания функций, которые «принимают все совместимые типы»; объявляйте шаблоны функций-членов для «обобщенного
    копирования конструктора» или «обобщенной операции присваивания», когда вам также нужно объявить обычный конструктор
    копирования и оператор присваивания копирования).

45. Определите нечленские функции, когда требуется преобразование типов (когда вы пишете шаблон класса, и он
    предоставляет функции, связанные с этим шаблоном, которые поддерживают «неявное преобразование типов всех
    параметров», определите эти функции как «дружественные функции внутри шаблона класса»).

46. Используйте классы свойств для отображения информации о типах (классы свойств с помощью шаблонов и «специализации
    шаблонов» делают информацию о типах доступной во время компиляции, используя технику перегрузки (overloading) для
    выполнения тестов if…else для типов во время компиляции).

47. Познакомьтесь с метапрограммированием на шаблонах (метапрограммирование на шаблонах (TMP, template metaprogramming)
    позволяет переместить работу из времени выполнения во время компиляции, что позволяет обнаруживать ошибки раньше и
    повышать эффективность выполнения; TMP может использоваться для генерации пользовательского кода на основе
    комбинаций выбора политик, а также для предотвращения генерации кода, который не подходит для некоторых специальных
    типов).

48. Познакомьтесь с поведением new-handler (set_new_handler позволяет клиентам указать функцию, которая будет
    вызываться, если не удается удовлетворить запрос на выделение памяти; nothrow new является довольно ограниченным
    инструментом, поскольку он применим только к выделению памяти (operator new), а вызываемый затем конструктор все
    равно может выбросить исключение).

49. Познакомьтесь с правильным временем замены new и delete (чтобы обнаружить ошибки использования, собрать
    статистическую информацию об использовании динамически выделенной памяти, увеличить скорость выделения и
    освобождения, уменьшить дополнительные расходы на пространство, вызываемые менеджером памяти по умолчанию, исправить
    неоптимальное выравнивание в менеджере памяти по умолчанию, сгруппировать связанные объекты вместе, получить
    нетрадиционное поведение).

50. При написании new и delete следуйте общепринятым правилам (operator new должен содержать бесконечный цикл и в нем
    пытаться выделить память; если он не может удовлетворить запрос на память, он должен вызвать new-handler; он также
    должен иметь возможность обрабатывать запросы на 0 байт; версии класса также должны обрабатывать «неправильные (
    ошибочные) запросы большего размера»; operator delete должен ничего не делать, если получает нулевой указатель;
    версии класса также должны обрабатывать «неправильные (ошибочные) запросы большего размера»).

51. Если вы написали placement new, напишите и placement delete (когда вы пишете placement operator new, убедитесь, что
    вы также написали соответствующий placement operator delete, иначе может произойти скрытая и периодическая утечка
    памяти; когда вы объявляете placement new и placement delete, убедитесь, что вы не закрываете их обычные версии).

52. Не игнорируйте предупреждения компилятора.

53. Ознакомьтесь со стандартной библиотекой, включая TR1 (TR1, C++ Technical Report 1, черновик стандарта C++11).

54. Ознакомьтесь с Boost (почти стандартная библиотека).

| А также спасибо | Источник | Исходные коды |
|:---------------:|:--------:|:-------------:|
|                 |  Jollu8  |  Open source  |
|  Stuckoverflow  |          | StackOverflow |



