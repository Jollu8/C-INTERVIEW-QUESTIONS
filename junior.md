# junior

- ### <span style="color:red">*Общие вопросы*</span>.

  #### 1. В чем заключаются основные принципы ООП?

    - <details><summary>Ответ:</summary>
      Основные принципы ООП включают в себя абстракцию, полиморфизм и наследование. Абстракция означает отделение концепции от ее экземпляра. Полиморфизм позволяет реализовывать задачи одной и той же идеи разными способами. Наследование позволяет создавать новые классы на основе уже существующих</abbr>
      </details>

  #### 2. Что такое сложность алгоритма?

    - <details><summary>Ответ:</summary>
      Сложность алгоритма - это понятие, характеризующее ресурс затратность алгоритма. Она может быть временной (сколько времени нужно центральному процессору для обработки данных) и связанной с памятью (какой объём памяти ЭВМ требуется для программной реализации алгоритма)1. Сложность обычно зависит от размеров входных данных
      </details>

  #### 3. Код работает неправильно. Что делать?
    - <details><summary>Ответ:</summary>

      ## Если ваш код работает неправильно, вы можете попробовать выполнить следующие шаги:
        - Проверьте, правильно ли вы понимаете, что должен делать ваш код.
        - Проверьте входные данные и убедитесь, что они соответствуют ожиданиям.
        - Используйте отладку или добавьте операторы вывода в ключевых местах кода, чтобы увидеть, какие значения
          принимаютпеременные во время выполнения.
        - Проверьте логику вашего кода и убедитесь, что все условия и циклы работают правильно.
        - Если вы используете сторонние библиотеки или функции, убедитесь, что вы используете их правильно.
        - Если проблема не решается, попробуйте обратиться за помощью к другим разработчикам или на форумах
          программистов.

      </details>

  #### 4. Объясните такие структуры данных, как стек и очередь.

    - <details><summary>Ответ:</summary>

        - Стек и очередь - это две разные структуры данных. Стек - это структура данных с доступом к элементам по
          принципу LIFO (Last In First Out - Последний пришел - первый вышел). Это означает, что данные добавляются в
          начало (или конец) стека, откуда же и извлекаются¹.
        - Очередь - это структура данных с доступом к элементам по принципу FIFO (First In First Out - Первый пришел -
          Первый вышел). Это означает, что данные добавляются в конец очереди, а извлекаются из начала¹.
        - В C++ вы можете использовать стандартные контейнеры `stack` и `queue` для работы со стеком и очередью
          соответственно.
        - [(1) c++ - Что такое стеки и очереди? - Stack Overflow на русском.](https://ru.stackoverflow.com/questions/32406/%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D1%81%D1%82%D0%B5%D0%BA%D0%B8-%D0%B8-%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D0%B8)
        - [пример кода](Codes/junior/code_4.cpp)
      </details>

  #### 5. Какие книги, связанные с программированием, читали? Чему с них научились?

    - <details><summary>Ответ:</summary>

        - Есть множество книг по программированию на C++, которые могут помочь вам изучить этот язык. Вот несколько
          книг, которые могут быть полезными:
        - Антон Спрол. «Думай как программист. Креативный подход к созданию кода. C++ версия» - эта книга учит решать
          проблемы с помощью программирования и развивать навыки алгоритмического мышления1.
        - Макс Шлее. «Qt 5.10. Профессиональное программирование на C++» - эта книга посвящена использованию фреймворка
          Qt для создания приложений на C++1.
        - Федор Пикус. «Идиомы и паттерны проектирования в современном С++» - эта книга знакомит с идиомами и паттернами
          проектирования, используемыми в современном C++1.
        - Алексей Васильев. «Программирование на C++ в примерах и задачах» - эта книга содержит множество примеров и
          задач для практического изучения C++1.
        - Мариус Бансила. «Решение задач на современном С++» - эта книга посвящена решению различных задач с
          использованием современного C++1.
        - Каждая из этих книг имеет свою специфику и может быть полезна в зависимости от того, что вы хотите изучить.
     </details>

  #### 6. Что интересного нашли в новых стандартах С++17, С++20, C++23 ?

    - <details><summary>Ответ:</summary>

        - Новые стандарты C++17, C++20 и C++23 вводят множество новых возможностей и улучшений в язык C++. Например, в
          C++17 были добавлены такие возможности, как if и switch с инициализацией, структурированные привязки,
          встраиваемые переменные и многое другое.
        - C++20 - это практически новый язык с большим количеством нововведений. Он вводит такие возможности, как
          модули, корутины, концепции и многое другое1.
        - C++23 - это следующая версия стандарта C++, которая находится в разработке. Она будет содержать еще больше
          новых возможностей и улучшений2.
      </details>

  #### 7. Что такое таблица ASCII?

    - <details><summary>Ответ:</summary>

        - Таблица ASCII (American Standard Code for Information Interchange) - это таблица кодировки символов, в которой
          каждой букве, числу или знаку соответствует определенное число. В стандартной таблице ASCII 128 символов,
          пронумерованных от 0 до 1271.
        - Таблица ASCII была разработана и стандартизирована в США в 1963 году и определяет коды для символов, таких как
          десятичные цифры, латинский алфавит, знаки препинания и управляющие символы2.

          <img src="Images/ASCII_Code_Chart.svg.png" >
      </details>

  #### 8. Что такое Unicode?

    - <details><summary>Ответ:</summary>

        - Unicode - это стандарт информационных технологий для последовательного кодирования, представления и обработки
          текста, выраженного в большинстве письменных систем мира. Стандарт, который поддерживается Консорциумом
          Unicode, определяет 149 186 символов, охватывающих 161 современный и исторический скрипт, а также символы,
          тысячи эмодзи (включая цветные) и невизуальные управляющие и форматирующие коды1.
        - Успех Unicode в объединении наборов символов привел к его широкому и преобладающему использованию в
          интернационализации и локализации компьютерного программного обеспечения. Стандарт был реализован во многих
          современных технологиях, включая современные операционные системы, XML, JSON и большинство современных языков
          программирования, иногда только в форме UTF-81.

     </details>

  #### 9. Что такое паттерны проектирования и для чего их используют?

    - <details><summary>Ответ:</summary>

        - Паттерны проектирования - это типичные решения общих проблем проектирования, которые возникают при разработке
          программного обеспечения. Они представляют собой проверенные временем и эффективные решения, которые могут
          быть использованы для решения определенных проблем в определенных ситуациях.
        - Один из паттернов проектирования, который может быть использован в C++, - это паттерн Строитель (Builder). Это
          порождающий паттерн проектирования, который позволяет создавать объекты пошагово1. Вот простой пример
          использования этого паттерна в C++:
        - В [этом примере](Codes/junior/code_9.cpp) мы используем паттерн Строитель для создания разных видов пиццы.
          Класс Cook использует объект PizzaBuilder для построения пиццы пошагово. Мы можем использовать разные
          реализации PizzaBuilder (в нашем случае HawaiianPizzaBuilder и SpicyPizzaBuilder) для создания разных видов
          пиццы.
      </details>

  #### 10. Паттерны Singleton, Strategy, Template-Method, Decorator?

    - <details><summary>Ответ:</summary>

        - Singleton, Strategy, Template-Method и Decorator - это четыре разных паттерна проектирования, которые могут
          быть использованы в C++.
        - Singleton - это порождающий паттерн проектирования, который гарантирует, что у класса есть только один
          экземпляр, и предоставляет глобальную точку доступа к этому экземпляру.
        - Strategy - это поведенческий паттерн проектирования, который определяет семейство алгоритмов, инкапсулирует
          каждый из них и делает их взаимозаменяемыми. Он позволяет алгоритму изменяться независимо от клиентов, которые
          его используют.
        - Template-Method - это поведенческий паттерн проектирования, который определяет скелет алгоритма в операции,
          оставляя некоторые шаги для переопределения подклассами. Он позволяет подклассам переопределять определенные
          шаги алгоритма без изменения его структуры.
        - Decorator - это структурный паттерн проектирования, который позволяет динамически добавлять новую
          функциональность к объекту, обертывая его в декоратор.
        - В [этом примере](Codes/junior/jcode_10.cpp) мы используем паттерн Singleton для создания единственного
          экземпляра класса Singleton. Метод getInstance возвращает ссылку на этот единственный экземпляр. Конструктор
          класса Singleton является закрытым, чтобы предотвратить создание дополнительных экземпляров.
      </details>

  #### 11. Для чего нужны модульные тесты?

    - <details><summary>Ответ:</summary>

        - Модульные тесты - это тесты, которые проверяют отдельные модули или компоненты программного обеспечения. Они
          используются для обеспечения того, что каждый модуль работает правильно и соответствует спецификации.
        - Модульные тесты имеют множество преимуществ. Они помогают обнаруживать ошибки на ранних стадиях разработки,
          упрощают внесение изменений в код, улучшают качество кода и увеличивают скорость разработки.
        - ```c++
          #include <gtest/gtest.h>
          int add(int a, int b) {
          return a + b;
          }
          TEST(AddTest, PositiveNumbers) {
            EXPECT_EQ(add(1, 2), 3);
            EXPECT_EQ(add(10, 20), 30);
          }
          TEST(AddTest, NegativeNumbers) {
            EXPECT_EQ(add(-1, -2), -3);
            EXPECT_EQ(add(-10, -20), -30);
          }
          int main(int argc, char **argv) {
            ::testing::InitGoogleTest(&argc, argv);
            return RUN_ALL_TESTS();
          }
          ```
        - В этом примере мы определяем функцию add, которая складывает два числа. Затем мы определяем два модульных
          теста с помощью макросов TEST. Первый тест проверяет, что функция add правильно складывает положительные
          числа. Второй тест проверяет, что функция add правильно складывает отрицательные числа. Мы используем макрос
          EXPECT_EQ для проверки равенства ожидаемого и фактического результатов.
      </details>

  #### 12. Какая разница между модульными и интеграционными тестами?

    - <details><summary>Ответ:</summary>

        - Модульные и интеграционные тесты - это два разных типа тестирования, которые используются для проверки разных
          аспектов программного обеспечения.
        - Модульные тесты фокусируются на проверке отдельных модулей или компонентов программного обеспечения. Они
          используются для обеспечения того, что каждый модуль работает правильно и соответствует спецификации.
          Модульные тесты обычно пишутся разработчиками и выполняются автоматически в процессе разработки.
        - Интеграционные тесты фокусируются на проверке взаимодействия между модулями или компонентами программного
          обеспечения. Они используются для обеспечения того, что различные части программного обеспечения работают
          вместе правильно. Интеграционные тесты могут быть более сложными, чем модульные тесты, так как они требуют
          настройки и запуска всей системы.
        - Основная разница между модульными и интеграционными тестами заключается в том, что модульные тесты
          фокусируются на проверке отдельных модулей, в то время как интеграционные тесты фокусируются на проверке
          взаимодействия между модулями.

      </details>

  #### 13. Что такое TDD?

    - <details><summary>Ответ:</summary>

        - TDD (Test-Driven Development, Разработка через тестирование) - это метод разработки программного обеспечения,
          при котором тесты пишутся до написания кода. В TDD разработчик сначала пишет модульный тест, который описывает
          ожидаемое поведение новой функциональности. Затем разработчик пишет код, который удовлетворяет этому тесту.
          После этого код рефакторится, чтобы улучшить его качество и устранить дублирование.
        - Основная идея TDD - это использование тестов как способа определения требований к коду и обеспечения того, что
          код работает правильно. TDD помогает обнаруживать ошибки на ранних стадиях разработки, упрощает внесение
          изменений в код и улучшает качество кода.
        - TDD состоит из трех основных шагов: красный, зеленый и рефакторинг. На шаге "красный" разработчик пишет тест,
          который не проходит. На шаге "зеленый" разработчик пишет код, который удовлетворяет тесту. На шаге "
          рефакторинг" разработчик улучшает код, не меняя его поведение. Эти шаги повторяются для каждой новой
          функциональности.
      </details>

---

- ### <span style="color:red">Метапрограммирование</span>.

  #### 14. Что такое шаблонный класс и шаблонная функция?
    - <details><summary>Ответ:</summary>

        - Шаблонный класс и шаблонная функция - это два механизма в C++, которые позволяют создавать обобщенные классы и
          функции.
        - Шаблонный класс - это класс, который определяется с использованием параметров типа. Эти параметры типа могут
          быть использованы внутри класса для определения типов данных, которые используются классом. Шаблонный класс
          может быть использован для создания объектов с разными типами данных.
        - В [этом примере](Codes/junior/jcode_14_1.cpp) мы определяем шаблонный класс MyPair, который имеет один
          параметр типа T. Этот параметр типа используется для определения типов данных членов first и second. Мы можем
          использовать этот шаблонный класс для создания объектов с разными типами данных, например int и std::string.
        - Шаблонная функция - это функция, которая определяется с использованием параметров типа. Эти параметры типа
          могут быть использованы внутри функции для определения типов данных, которые используются функцией. Шаблонная
          функция может быть вызвана с разными типами данных.
        - В [этом примере](Codes/junior/jcode_14_2.cpp) мы определяем шаблонную функцию getMax, которая имеет один
          параметр типа T. Этот параметр типа используется для определения типов данных аргументов a и b. Мы можем
          вызывать эту шаблонную функцию с разными типами данных, например int, double и std::string.
      </details>

  #### 15. Что такое конструкторы? Какие типы знаете?

    - <details><summary>Ответ:</summary>

        - Конструктор - это специальный метод класса в C++, который вызывается при создании нового объекта этого класса.
          Конструктор используется для инициализации объекта и установки его начального состояния.
        - В C++ есть несколько типов конструкторов:
            1. Конструктор по умолчанию - это конструктор, который не принимает никаких аргументов. Он вызывается, когда
               объект создается без указания аргументов.
            2. Конструктор с параметрами - это конструктор, который принимает один или несколько аргументов. Он
               используется для инициализации объекта с помощью переданных аргументов.
            3. Конструктор копирования - это конструктор, который принимает ссылку на объект того же класса в качестве
               аргумента. Он используется для создания нового объекта как копии существующего объекта.
            4. Конструктор перемещения - это конструктор, который принимает rvalue-ссылку на объект того же класса в
               качестве аргумента. Он используется для перемещения ресурсов из одного объекта в другой.
        - В этом [примере](Codes/junior/jcode_15.cpp) мы определяем класс MyClass, который имеет четыре конструктора:
          конструктор по умолчанию, конструктор с параметрами, конструктор копирования и конструктор перемещения. Мы
          можем использовать эти конструкторы для создания разных объектов класса MyClass. В функции main мы создаем
          четыре объекта класса MyClass, используя разные типы конструкторов.
      </details>

  #### 16. Может ли конструктор быть шаблонной функцией?
    - <details><summary>Ответ:</summary>

        - Да, конструктор может быть шаблонной функцией. Шаблонные функции позволяют создавать функции, которые могут
          работать с разными типами данных без необходимости переписывать код для каждого типа. Однако, виртуальный
          метод
          не может быть шаблонным
    </details>

  #### 17. Может ли виртуальная функция быть шаблонной?

    - <details><summary>Ответ:</summary>

      Виртуальна функция не может быть шаблонной,
      потому что это слишком большое усложнение устройства таблицы виртуальных функций.
      Шаблонные функции генерируются на этапе компиляции (статическое связывание),
      а объявление функции виртуальной означает, что компилятор должен выполнить позднее связывание (динамическое)
      и на этапе выполнения вызовется "нужная функция" для каждого класса через указатель на таблицу виртуальных функций
      плюс смещение. Эта таблица должна быть фиксированного размера и содержать только одну запись для виртуальной
      функции,
      а в случае шаблонной виртуальной функции их будет несколько и их количество не будет известно
      до трансляции всей программы.

    </details>

  #### 18. Что такое инстанциация шаблона?

    - <details><summary>Ответ:</summary>

        - Инстанциация шаблона - это процесс создания конкретного экземпляра класса или функции из шаблона с
          использованием заданных аргументов шаблона. Во время компиляции компилятор автоматически генерирует код для
          каждого уникального набора аргументов шаблона, которые используются в программе. Этот процесс также называется
          “развертыванием шаблона”

    </details>

  #### 19. Что такое специализация шаблона? Частичная специализация шаблона?

    - <details><summary>Ответ:</summary>

        - Специализация шаблона - это версия шаблона, которая предназначена для определенного набора аргументов шаблона.
          Специализация шаблона может быть полной или частичной. Полная специализация шаблона определяет реализацию
          шаблона для конкретного набора аргументов шаблона, в то время как частичная специализация шаблона определяет
          реализацию для подмножества возможных аргументов шаблона .
        - Частичная специализация шаблона позволяет настроить код шаблона для определенных типов. Например, если шаблон
          имеет несколько типов, и только некоторые из них требуют специализации, то результат для остальных типов
          параметризован шаблоном.

    </details>

  #### 20. Расскажите об имплементации шаблонных классов в срр-файле?

    - <details><summary>Ответ:</summary>

        - Шаблонные классы обычно определяются в заголовочных файлах, а не в файлах с исходным кодом (cpp-файлах). Это
          связано с тем, что компилятору необходимо иметь доступ к полному определению шаблона, чтобы создать экземпляр
          шаблона для конкретного типа. Если определение шаблона находится в cpp-файле, то компилятор не сможет создать
          экземпляры шаблона для других единиц трансляции.
        - Однако, в некоторых случаях можно разделить определение и реализацию шаблонного класса между заголовочным и
          cpp-файлом. В этом случае необходимо явно инстанцировать шаблон для каждого используемого типа в cpp-файле.
          Это может быть полезно для уменьшения времени компиляции и улучшения организации кода, но может привести к
          увеличению размера исполняемого файла 1.

    </details>

----

- ### <span style="color:red"> Препроцессор и компиляция <span/>

  #### 21. Как проходит процесс компиляции срр-файлов в бинарный файл?
    - <details><summary>Ответ:</summary>

        - омпиляция срр-файлов в бинарный файл проходит в несколько этапов. Во-первых, компилятор преобразует исходный
          код
          на языке C++ в объектный код, который представляет собой машинный код, но еще не связан с другими объектными
          файлами. Затем линковщик объединяет объектные файлы и библиотеки в исполняемый бинарный файл.
        - В процессе компиляции компилятор выполняет множество задач, таких как проверка синтаксиса, оптимизация кода и
          генерация кода для целевой архитектуры. Линковщик затем связывает объектные файлы и решает все ссылки на
          символы,
          чтобы создать исполняемый бинарный файл.
        - В зависимости от используемого компилятора и настроек, этот процесс может быть настроен для оптимизации
          скорости
          выполнения или размера исполняемого файла.
    </details>

  #### 22. Что такое препроцессор?

    - <details><summary>Ответ:</summary>

        - Препроцессор - это программа, которая обрабатывает исходный код перед компиляцией. Он выполняет
          макроподстановки и обрабатывает директивы препроцессора, такие как #define, #include и #ifdef. Препроцессор
          работает на уровне текста и не имеет информации о синтаксисе или семантике языка программирования.
        - Препроцессор используется для автоматической генерации кода, условной компиляции и включения заголовочных
          файлов. Он позволяет управлять компиляцией кода с помощью директив препроцессора, которые указывают
          компилятору, какие части кода следует включить или исключить в зависимости от определенных условий.
        - В [этом примере](Codes/junior/jcode_22.cpp), если макрос DEBUG определен (что достигается с помощью директивы
          #define DEBUG), то программа выведет сообщение “Debug mode is ON”. Если же макрос DEBUG не определен (
          например, если строка #define DEBUG закомментирована), то программа выведет сообщение “Debug mode is OFF”.
      </details>

  #### 23. Как работает препроцессор?

    - <details><summary>Ответ:</summary>

        - Препроцессор работает на уровне текста и обрабатывает исходный код перед компиляцией. Он выполняет
          макроподстановки и обрабатывает директивы препроцессора, такие как `#define`, `#include` и `#ifdef`.
        - Вот как работает препроцессор:
            1. Сначала препроцессор сканирует исходный код и ищет директивы препроцессора, которые начинаются с
               символа `#`.
            2. Когда препроцессор находит директиву, он выполняет соответствующее действие. Например,
               директива `#define` используется для определения макроса, а директива `#include` используется для
               включения содержимого другого файла в текущий файл.
            3. Препроцессор также выполняет макроподстановки. Это означает, что он заменяет все вхождения макроса на его
               определение.
            4. После того, как препроцессор обработал все директивы и выполнил все макроподстановки, он генерирует новый
               текстовый файл, который содержит преобразованный код. Этот файл затем передается компилятору для
               компиляции.
        - Препроцессор работает автоматически и является частью процесса компиляции. Он позволяет программистам
          использовать макросы и директивы препроцессора для управления компиляцией кода и автоматической генерации
          кода.
        - В [этом примере](Codes/junior/jcode_23_1.cpp) мы определяем два макроса с помощью директивы #define: PI и
          SQUARE. Макрос PI имеет значение 3.14, а макрос SQUARE является функциональным макросом, который возвращает
          квадрат своего аргумента.
        - В функции main мы используем эти макросы для вывода значения PI и квадрата числа 5. Препроцессор заменит
          макросы на их определения, так что после обработки препроцессором код будет выглядеть так:
        - Этот [код затем](Codes/junior/jcode_23_2.cpp) будет скомпилирован и выполнен.
    </details>

  #### 24. Какие знаете команды препроцессора?

    - <details><summary>Ответ:</summary>

        - Препроцессор C++ поддерживает несколько директив, которые начинаются с символа #. Вот некоторые из наиболее
          часто
          используемых директив препроцессора:
            1. #define - определяет макрос.
            2. #undef - отменяет определение макроса.
            3. #include - включает содержимое другого файла в текущий файл.
            4. #if, #elif, #else, #endif - используются для условной компиляции кода.
            5. #ifdef, #ifndef - проверяют, определен ли макрос.
            6. #error - генерирует ошибку компиляции с указанным сообщением.
            7. #pragma - используется для передачи специфических для реализации инструкций компилятору.

        - Эти директивы позволяют программистам управлять компиляцией кода и использовать макросы для автоматической
          генерации кода. Они являются мощным инструментом, который может упростить написание и поддержку кода, но также
          может привести к сложностям, если используется неправильно.

     </details>

  #### 25. Как работает директива include?

    - <details><summary>Ответ:</summary>

        - Директива #include используется для включения содержимого другого файла в текущий файл. Это позволяет
          программистам разбить код на несколько файлов и повторно использовать код, определенный в одном файле, в
          других файлах.
        - Когда препроцессор находит директиву #include, он заменяет ее содержимым указанного файла. Содержимое файла
          вставляется в точку, где находится директива #include, как если бы оно было написано непосредственно в этом
          месте.
        - Вот простой пример использования директивы #include:
        - ```c++
          // main.cpp
          #include <iostream>
          #include "myheader.h"
          int main() {
            std::cout << "The value of PI is: " << PI << std::endl;
            return 0;
          }
        - ```
          ```c++
          // myheader.h
          #define PI 3.14
          ```
        - В этом примере мы имеем два файла: main.cpp и myheader.h. В файле main.cpp мы используем директиву #include,
          чтобы включить содержимое файла myheader.h. Файл myheader.h содержит определение макроса PI.
        - Когда препроцессор обрабатывает файл main.cpp, он заменит директиву #include "myheader.h" на содержимое файла
          myheader.h. Таким образом, после обработки препроцессором код будет выглядеть так:
        - ```c++
           // main.cpp
           #include <iostream>
           #define PI 3.14
           int main() {
            std::cout << "The value of PI is: " << PI << std::endl;
            return 0;
           }
          ```
        - Этот код затем будет скомпилирован и выполнен.
    </details>

  #### 26. Как работает директива define?

    - <details><summary>Ответ:</summary>

        - Директива #define используется для определения макросов. Макрос - это фрагмент текста, который заменяется на
          другой текст во время обработки препроцессором. Макросы могут быть простыми, например, для определения
          констант, или сложными, например, для генерации кода.
        - Синтаксис директивы #define выглядит так:
        - ```c++
          #define имя_макроса замена
          ```
        - имя_макроса - это имя макроса, которое будет использоваться в коде для ссылки на макрос. замена - это текст,
          который будет вставлен вместо имени макроса при обработке препроцессором.
        - Вот простой пример использования директивы #define:
        - ```c++
          #include <iostream>
          #define PI 3.14
          int main() {
          std::cout << "The value of PI is: " << PI << std::endl;
          return 0;
          }
          ```
        - В этом примере мы используем директиву #define, чтобы определить макрос с именем PI и значением 3.14. В
          функции main мы используем этот макрос для вывода значения PI.
        - Когда препроцессор обрабатывает этот код, он заменит все вхождения макроса PI на его значение 3.14. Таким
          образом, после обработки препроцессором код будет выглядеть так:
        - ```c++
          #include <iostream>
          int main() {
            std::cout << "The value of PI is: " << 3.14 << std::endl;
            return 0;
          }
          ```
        - Этот код затем будет скомпилирован и выполнен.
    </details>

  #### 27. Что именно линкует линкер?

    - <details><summary>Ответ:</summary>

        - Линкер - это программа, которая объединяет несколько объектных файлов и библиотек в один исполняемый файл. Он
          решает все ссылки на символы, которые были определены в других объектных файлах или библиотеках.
        - Объектные файлы содержат машинный код и данные, которые были сгенерированы компилятором из исходного кода. Они
          также содержат информацию о символах, которые определены в этом файле, и ссылки на символы, которые
          используются, но не определены.
        - Линкер проходит по всем объектным файлам и библиотекам и строит таблицу символов, которая содержит информацию
          обо всех определенных символах. Затем он решает все ссылки на символы, заменяя ссылки на адреса
          соответствующих символов в таблице символов.
        - Например, если функция `main` в одном объектном файле вызывает функцию `foo`, которая определена в другом
          объектном файле, то линкер найдет адрес функции `foo` в таблице символов и заменит ссылку на функцию `foo` в
          коде функции `main` на этот адрес.
        - После того, как линкер решил все ссылки на символы, он объединяет код и данные из всех объектных файлов и
          библиотек в один исполняемый файл. Этот файл содержит все необходимое для запуска программы.

        - ![img.png](Images/img_1.png)

    </details>

  #### 28. Что такое оптимизация компилятора?

    - <details><summary>Ответ:</summary>

        - Оптимизация компилятора - это процесс улучшения эффективности и производительности сгенерированного
          компилятором кода. Компиляторы используют различные техники оптимизации, чтобы улучшить скорость выполнения
          кода, уменьшить размер исполняемого файла и улучшить другие аспекты производительности.
        - Оптимизация компилятора может включать в себя такие техники, как удаление недостижимого кода, устранение общих
          подвыражений, свертка констант, раскрытие циклов и многие другие. Компиляторы могут использовать различные
          уровни оптимизации, которые определяют, какие техники оптимизации будут использоваться и насколько агрессивно
          они будут применяться.
        - Оптимизация компилятора является сложным процессом, который требует глубокого понимания архитектуры компьютера
          и языка программирования. Она может значительно улучшить производительность программы, но также может привести
          к сложностям при отладке и поведению, которое может быть неожиданным для программиста.

    </details> 

  #### 29. Что такое флажки компиляции?

    - <details><summary>Ответ:</summary>

        - Флажки компиляции - это опции командной строки, которые передаются компилятору для управления различными
          аспектами процесса компиляции. Они позволяют программистам настраивать поведение компилятора и влиять на
          результаты компиляции.
        - Например, флажки компиляции могут использоваться для выбора уровня оптимизации, включения или отключения
          предупреждений, указания путей к заголовочным файлам и библиотекам, выбора стандарта языка и многого другого.
        - Флажки компиляции обычно указываются в командной строке при запуске компилятора. Например, чтобы
          скомпилировать файл main.cpp с оптимизацией уровня 3 и предупреждениями обо всех ошибках, можно использовать
          следующую команду (для компилятора GCC):
        - ```c++
          g++ -O3 -Wall main.cpp
          ```
        - В этом примере -O3 - это флажок компиляции, который указывает компилятору использовать уровень оптимизации 3,
          а -Wall - это флажок компиляции, который включает предупреждения обо всех ошибках.
        - Флажки компиляции могут быть разными для разных компиляторов, поэтому важно проверить документацию к вашему
          компилятору, чтобы узнать, какие флажки доступны и как их использовать.
      </details>

  #### 30. Как защитить хедер от повторного включения?

    - <details><summary>Ответ:</summary>

        - Чтобы защитить заголовочный файл (header) от повторного включения, можно использовать так называемые “header
          guards” (стражи заголовков). Header guards - это конструкции препроцессора, которые предотвращают повторное
          включение содержимого заголовочного файла.
        - Header guards работают следующим образом: в начале заголовочного файла определяется макрос с уникальным
          именем, а затем весь остальной код файла заключается в условную конструкцию препроцессора, которая проверяет,
          определен ли этот макрос. Если макрос уже определен, то содержимое файла не будет включено повторно.
        - Вот пример использования header guards в заголовочном файле myheader.h:
        - ```c++
           #ifndef MYHEADER_H
           #define MYHEADER_H

           // содержимое заголовочного файла

           #endif // MYHEADER_H
          ```

        - В этом примере мы используем директивы препроцессора #ifndef, #define и #endif, чтобы создать header guard.
          Макрос MYHEADER_H используется как уникальный идентификатор для этого заголовочного файла.
        - Когда этот файл включается в другой файл с помощью директивы #include, препроцессор проверяет, определен ли
          макрос MYHEADER_H. Если он не определен, то препроцессор определяет его и включает содержимое файла. Если же
          макрос уже определен (например, если файл был включен ранее), то содержимое файла не будет включено повторно.
        - Использование header guards помогает предотвратить проблемы, связанные с повторным включением заголовочных
          файлов, такие как переопределение макросов и функций.

     </details>

  #### 31. Что делает директива include?

    - <details><summary>Ответ:</summary>

        - Директива #include используется для включения содержимого другого файла в текущий файл. Это позволяет
          программистам разбить код на несколько файлов и повторно использовать код, определенный в одном файле, в
          других файлах.
        - Когда препроцессор находит директиву #include, он заменяет ее содержимым указанного файла. Содержимое файла
          вставляется в точку, где находится директива #include, как если бы оно было написано непосредственно в этом
          месте.
        - Вот простой пример использования директивы #include:
        - ```c++
           // main.cpp
           #include <iostream>
           #include "myheader.h"
           int main() {
              std::cout << "The value of PI is: " << PI << std::endl;
              return 0;
            }
          ```
        - ```c++
            // myheader.h
            #define PI 3.14
          ```  
        - В этом примере мы имеем два файла: main.cpp и myheader.h. В файле main.cpp мы используем директиву #include,
          чтобы включить содержимое файла myheader.h. Файл myheader.h содержит определение макроса PI.
        - Когда препроцессор обрабатывает файл main.cpp, он заменит директиву #include "myheader.h" на содержимое файла
          myheader.h. Таким образом, после обработки препроцессором код будет выглядеть так:
        - ```c++
            // main.cpp
            #include <iostream>
            #define PI 3.14
            int main() {
               std::cout << "The value of PI is: " << PI << std::endl;
               return 0;
            }
          ```
          Этот код затем будет скомпилирован и выполнен.
      </details>

  #### 32. Как работают макросы?

    - <details><summary>Ответ:</summary>

        - В языках С и С++ есть такой механизм, как препроцессор. Он обрабатывает исходный код программы ДО того, как
          она будет скомпилирована. Макросы в С и С++ - это инструкции препроцессору, которые позволяют заменять текст в
          исходном коде перед компиляцией1. Препроцессор развертывает макросы во всех строках, кроме директив
          препроцессора, которые имеют # в качестве первого символа, не являющегося пробелом. Он расширяет макросы в
          части некоторых директив, которые не пропускаются в рамках условной компиляции
    </details>

--- 

- ### <span style="color:red"> Язык C<span/>

  #### 33. Как static влияет на глобальные/локальные переменные?

    - <details><summary>Ответ:</summary>

        - Ключевое слово static имеет разные эффекты в зависимости от того,
          используется ли оно с глобальными или локальными переменными. Для глобальных переменных, static ограничивает
          область видимости переменной до файла, в котором она определена. Это означает, что переменная будет доступна
          только внутри этого файла и не будет видна из других файлов1. Для локальных переменных, static изменяет время
          жизни переменной. Обычно локальные переменные создаются при входе в блок кода и уничтожаются при выходе из
          него. Однако, если локальная переменная объявлена как static, ее значение сохраняется между вызовами функции,
          в которой она определена.
        - Этот [код объявляет](Codes/junior/jcode_33.cpp) переменную x, присваивает ей значение 5, затем изменяет его на
          10 и выводит оба значения на экран. Комментарии в коде начинаются с символов // и продолжаются до конца
          строки. Они используются для пояснения кода и не влияют на его выполнение
     </details>

  #### 34. Как сonst влияет на переменную?

    - <details><summary>Ответ:</summary>

        - Ключевое слово const в языке программирования C используется для обозначения переменных, которые не могут быть
          изменены после инициализации. Это может быть использовано при объявлении констант 1. Например, const int x =
          5; означает, что значение x равно 5 и не может быть изменено в дальнейшем.
        - Вот простой пример использования const в C:
        - ```c
          #include <stdio.h>
          int main(void) {
              const int x = 5;
              // x = 10; // Ошибка компиляции: нельзя изменить значение константы
              printf("x = %d\n", x);
              return 0;
          }
          ```
        - В этом примере переменная x объявлена как const int, что означает, что ее значение не может быть изменено
          после инициализации. Если вы попытаетесь раскомментировать строку x = 10;, то получите ошибку компиляции,
          потому что нельзя изменить значение константы.

    </details>

  #### 35. Какие варианты использования extern знаете?∆

    - <details><summary>Ответ:</summary>

        - Ключевое слово extern в C используется для расширения области видимости переменных и функций между несколькими
          файлами исходного кода. В случае функций, ключевое слово extern используется неявно, но для переменных его
          необходимо использовать явно .
        - Один из вариантов использования extern - это объявление глобальных переменных в одном файле и использование их
          в других файлах с помощью ключевого слова extern. Например:
        - ```c
          // file1.
          int x = 10;
          // file2.c
          #include <stdio.h>
          extern int x;
          int main(void) {
            printf("x = %d\n", x);
            return 0;
          }
          ```
        - В этом примере переменная x объявлена как глобальная переменная в файле file1.c, а затем используется в файле
          file2.c с помощью ключевого слова extern. Это позволяет расширить область видимости переменной x между двумя
          файлами. Надеюсь, это помогло вам понять, как использовать ключевое слово extern в C. Если у вас есть
          дополнительные вопросы, не стесняйтесь спрашиват
    </details>

  #### 36. Какие варианты использования volatile знаете?

    - <details><summary>Ответ:</summary>

        - Ключевое слово volatile в C используется для предотвращения оптимизации компилятором переменных, которые могут
          изменяться вне кода программы. Это может быть полезно в нескольких ситуациях, например:
            1. Когда вы работаете с аппаратным обеспечением, которое само изменяет значение переменной.
            2. Когда есть другой поток, который также использует переменную.
            3. Когда есть обработчик сигналов, который может изменить значение переменной 1.
        - Вот простой пример использования volatile в C:
        - ```c
          #include <stdio.h>
          #include <pthread.h>
          volatile int x = 0;
          void *increment(void *arg) {
           for (int i = 0; i < 1000000; i++) {
              x++;
           }
           return NULL;
          }
          int main(void) {
            pthread_t t1, t2;
            pthread_create(&t1, NULL, increment, NULL);
            pthread_create(&t2, NULL, increment, NULL);
            pthread_join(t1, NULL);
            pthread_join(t2, NULL);
            printf("x = %d\n", x);
            return 0;
          }
          ```
    </details>

  #### 37. Какие есть битовые операции?

    - <details><summary>Ответ:</summary>

        - В языке программирования C есть несколько битовых операций, которые позволяют работать с отдельными битами в
          числе. Вот список основных битовых операций:
            1. `&` (битовое И) - выполняет побитовое логическое И между двумя числами.
            2. `|` (битовое ИЛИ) - выполняет побитовое логическое ИЛИ между двумя числами.
            3. `^` (битовое исключающее ИЛИ) - выполняет побитовое логическое исключающее ИЛИ между двумя числами.
            4. `~` (битовое НЕ) - выполняет побитовое логическое НЕ над одним числом.
            5. `<<` (битовый сдвиг влево) - сдвигает биты числа влево на указанное количество позиций.
            6. `>>` (битовый сдвиг вправо) - сдвигает биты числа вправо на указанное количество позиций.
        - [Пример.](Codes/junior/jcode_37.cpp)
    </details>

  #### 38. Что такое булевая алгебра?

    - <details><summary>Ответ:</summary>

      [Булева алгебра](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D0%B0_%D0%BB%D0%BE%D0%B3%D0%B8%D0%BA%D0%B8)
      — это категория алгебры, в которой значения переменных являются значениями истинности, истинными и ложными, обычно
      обозначаемыми `1` и `0` соответственно. Он используется для анализа и упрощения цифровых схем или цифровых
      вентилей. Ее также называют бинарной алгеброй или логической алгеброй. Он был основополагающим при разработке
      цифровой электроники и предусмотрен во всех современных языках программирования. Он также используется в [теории
      множеств](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2)
      и статистике.

      Важными операциями, выполняемыми в булевой алгебре, являются конъюнкция `∧`, дизъюнкция `∨` и отрицание `¬` .
      Следовательно, эта алгебра сильно отличается от элементарной алгебры, где значения переменных являются числовыми,
      а над
      ними выполняются арифметические операции, такие как сложение, вычитание.
    </details>

  #### 39. Расскажите об этапах разработки библиотеки или программы.

    - <details><summary>Ответ:</summary>

        1. Планирование и анализ требований. На этом этапе определяются цели и требования к программе или библиотеке, а
           также проводится анализ рынка и конкурентов.
        2. Проектирование. На этом этапе разрабатывается архитектура программы или библиотеки, определяются основные
           компоненты и их взаимодействие.
        3. Реализация. На этом этапе происходит непосредственная разработка программы или библиотеки, написание кода и
           тестирование.
        4. Тестирование. На этом этапе проводится тестирование программы или библиотеки для обнаружения и исправления
           ошибок и несоответствий требованиям.
        5. Документирование. На этом этапе создается документация для программы или библиотеки, включая руководство
           пользователя, техническую документацию и примеры использования.
        6. Релиз и поддержка. На этом этапе программа или библиотека выпускается для использования пользователями, а
           также предоставляется поддержка для исправления ошибок и улучшения функциональности.
    </details>

  #### 40. Что такое алгоритмы сортировки и какие вы знаете?

    - <details><summary>Ответ:</summary>

        - Алгоритмы сортировки - это алгоритмы, которые используются для упорядочивания элементов в списке или массиве в
          определенном порядке (например, по возрастанию или убыванию). Существует множество различных алгоритмов
          сортировки, каждый из которых имеет свои преимущества и недостатки.
            1. Вот несколько наиболее распространенных алгоритмов сортировки:
            2. Сортировка пузырьком. Этот алгоритм сравнивает соседние элементы и меняет их местами, если они находятся
               в неправильном порядке. Процесс повторяется до тех пор, пока все элементы не будут отсортированы.
            3. Сортировка вставками. Этот алгоритм выбирает один элемент за другим и вставляет его в правильное место в
               отсортированной части массива.
            4. Сортировка выбором. Этот алгоритм находит наименьший (или наибольший) элемент в неотсортированной части
               массива и меняет его местами с первым (или последним) элементом.
            5. Сортировка слиянием. Этот алгоритм разбивает массив на две части, рекурсивно сортирует каждую из них, а
               затем объединяет их в отсортированный массив.
            6. Быстрая сортировка. Этот алгоритм выбирает опорный элемент, разбивает массив на две части таким образом,
               чтобы элементы меньше опорного были слева от него, а больше - справа, затем рекурсивно сортирует каждую
               из частей.
      </details>

  #### 41. Какие алгоритмы работы со строками знаете?

    - <details><summary>Ответ:</summary>

        - Существует множество алгоритмов для работы со строками на C++. Некоторые из них включают:
            1. Полиномиальное хеширование: позволяет эффективно отвечать на вопрос о равенстве строк, сравнивая их
               хеш-коды.
            2. Алгоритм Кнута – Морриса – Пратта (КМП): используется для поиска подстроки в строке.
            3. Префиксное дерево: используется для хранения и поиска строк.
            4. Алгоритм Ахо – Корасик: используется для поиска нескольких подстрок в тексте.
        - [Пример кода](Codes/junior/jcode_41.cpp)
    </details>

  #### 42. Какие алгоритмы на графах знаете?

    - <details><summary>Ответ:</summary>

        - Существует множество алгоритмов на графах. Некоторые из них включают:
            1. **Поиск в ширину**: используется для обхода графа или поиска кратчайшего пути между двумя вершинами¹.
            2. **Поиск в глубину**: используется для обхода графа или поиска циклов¹.
            3. **Кратчайший путь**: алгоритмы, такие как Дейкстры, Беллмана-Форда и Флойда-Уоршелла, используются для
               поиска кратчайшего пути между вершинами¹.
            4. **Обнаружение циклов**: используется для определения наличия циклов в графе¹.
            5. **Минимальное покрывающее дерево**: алгоритмы, такие как Краскала и Прима, используются для построения
               минимального покрывающего дерева¹.
            6. **Сильно связанные компоненты**: используется для определения сильно связанных компонент в
               ориентированном графе¹.
            7. **Топологическая сортировка**: используется для упорядочивания вершин в ациклическом ориентированном
               графе¹.
            8. **Раскраска графа**: используется для раскраски вершин или ребер графа согласно определенным правилам¹.
        - Это только некоторые из множества алгоритмов на графах. Вы можете узнать больше об этих и других алгоритмах на
          графах на сайтах, таких как [Википедия](https://ru.wikipedia.org/wiki/Категория:Алгоритмы_на_графах) ³.
            - [1] [10 анимированных алгоритмов на графах.](https://bing.com/search?q=%d0%b0%d0%bb%d0%b3%d0%be%d1%80%d0%b8%d1%82%d0%bc%d1%8b+%d0%bd%d0%b0+%d0%b3%d1%80%d0%b0%d1%84%d0%b0%d1%85)
            - [2] [Категория:Алгоритмы на графах — Википедия](https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B_%D0%BD%D0%B0_%D0%B3%D1%80%D0%B0%D1%84%D0%B0%D1%85)
              .

      </details>

  #### 43. Где может храниться переменная?

    -  <details><summary>Ответ:</summary>

        - В C++ переменные обычно хранятся в оперативной памяти. Место хранения переменной зависит от ее типа и области
          видимости:
            1. На стеке: если переменная является локальной для функции и не имеет статической продолжительности
               хранения1.
            2. На куче: если переменная была выделена с помощью оператора new или функции malloc1.
            3. В области данных: если переменная является глобальной или статической1.
       </details>

  #### 44. Какая разница между calloc и malloc?

    - <details><summary>Ответ:</summary>

        - `calloc` и `malloc` являются функциями для динамического выделения памяти в языке программирования C. Они обе
          выделяют блок памяти в куче, но есть несколько различий между ними:
        - `malloc` выделяет блок памяти указанного размера в байтах и возвращает указатель на начало блока. Содержимое
          блока памяти не инициализируется и может содержать мусорные данные.
        - `calloc` выделяет блок памяти для массива из указанного количества элементов указанного размера и возвращает
          указатель на начало блока. Содержимое блока памяти инициализируется нулями.
        - Основное различие между `calloc` и `malloc` заключается в том, что `calloc` инициализирует выделенную память
          нулями, в то время как `malloc` не инициализирует ее. Кроме того, `calloc` принимает два аргумента (количество
          элементов и размер каждого элемента), а `malloc` принимает только один аргумент (размер блока памяти в байтах)
          .
      </details>

  #### 45. Для чего используют realloc?

    - <details><summary>Ответ:</summary>

        - `realloc` - это функция для динамического выделения памяти в языке программирования C. Она используется для
          изменения размера ранее выделенного блока памяти. Это может быть полезно, если вам необходимо увеличить или
          уменьшить количество памяти, выделенной для массива или другой структуры данных.
        - `realloc` принимает два аргумента: указатель на ранее выделенный блок памяти и новый размер блока в байтах.
          Функция пытается изменить размер блока памяти на новый размер и возвращает указатель на новый блок памяти.
          Если изменение размера блока памяти невозможно, функция возвращает `NULL`.
        - Важно отметить, что `realloc` может переместить блок памяти в другое место, если изменение размера невозможно
          в текущем местоположении. Это означает, что указатели на старый блок памяти могут стать недействительными
          после вызова `realloc`. Поэтому необходимо всегда проверять возвращаемое значение `realloc` и обновлять
          указатели соответствующим образом.
    </details>

  #### 46. Что такое указатель?

    - <details><summary>Ответ:</summary>

        - Указатель - это переменная, которая хранит адрес другой переменной в памяти. Указатели используются для ссылки
          на переменные и передачи их в качестве аргументов функций. Они также используются для работы с массивами и
          динамическим выделением памяти. В языках программирования C и C++ указатели объявляются с помощью символа `*`
          после типа данных. Например, `int *p` объявляет указатель на переменную типа `int`. Значение указателя можно
          получить с помощью оператора `&`, который возвращает адрес переменной. Например, `p = &x` присваивает
          указателю `p` адрес переменной `x`. Чтобы получить значение переменной, на которую указывает указатель,
          используется оператор разыменования `*`. Например, `*p` возвращает значение переменной, на которую
          указывает `p`. Можно также изменять значение переменной, на которую указывает указатель, с помощью оператора
          разыменования. Например, `*p = 5` присваивает значение 5 переменной, на которую указывает `p`. Указатели
          являются мощным инструментом в языках программирования C и C++, но их использование требует осторожности и
          понимания того, как они работают.
    </details>

  #### 47. Каков размер указателя и от чего он зависит?

    - <details><summary>Ответ:</summary>

        - Размер указателя зависит от архитектуры компьютера и операционной системы. Указатель должен быть достаточно
          большим, чтобы хранить адрес любого места в памяти компьютера.
        - На 32-битных системах размер указателя обычно равен 4 байтам, так как максимальный размер адресного
          пространства составляет 2^32 байт. На 64-битных системах размер указателя обычно равен 8 байтам, так как
          максимальный размер адресного пространства составляет 2^64 байт.
        - В языках программирования C и C++ можно использовать оператор `sizeof` для определения размера указателя.
          Например, `sizeof(int*)` возвращает размер указателя на переменную типа `int` в байтах. Размер указателя на
          любой тип данных обычно одинаков, независимо от типа данных.
    </details>

  #### 48. Какие есть операции с указателями?

    - <details><summary>Ответ:</summary>

        - В языках программирования C и C++ существуют несколько операций, которые можно выполнять с указателями.
          Некоторые из них включают:
        - **Инициализация указателя**: указатель может быть инициализирован значением `NULL` или адресом переменной.
          Например:
          ```c++
          int x = 5;
          int *p = &x; // p указывает на x
          ```
        - **Разыменование указателя**: оператор `*` используется для доступа к значению переменной, на которую
          указывает указатель. Например:
          ```c++
          int x = 5;
          int *p = &x;
          int y = *p; // y равно 5
          ```
        - **Изменение значения переменной через указатель**: можно изменить значение переменной, на которую указывает
          указатель,
          используя оператор разыменования. Например:
          ```c++
          int x = 5;
          int *p = &x;
          *p = 10; // x теперь равно 10
          ```
        - **Арифметика указателей**: можно выполнять арифметические операции с указателями, такие как инкремент (`++`) и
          декремент (`--`), а также сложение и вычитание целых чисел. Это полезно при работе с массивами. Например:
          ```c++
          int arr[] = {1, 2, 3};
          int *p = arr; // p указывает на первый элемент массива
          p++; // p теперь указывает на второй элемент массива
          int y = *p; // y равно 2
          ```
        - **Сравнение указателей**: можно сравнивать два указателя с помощью операторов сравнения, таких как `==` и `!=`
          . Это
          полезно для проверки, указывают ли два указателя на одну и ту же переменную. Например:
          ```c++
          int x = 5;
          int *p1 = &x;
          int *p2 = &x;
          if (p1 == p2) {
              // p1 и p2 указывают на одну и ту же переменную
          }
          ```
      Это только некоторые из операций, которые можно выполнять с указателями в C и C++. Указатели являются мощным
      инструментом, но их использование требует осторожности и понимания того, как они работают.

     </details>

  ##### 49. Что такое struct?

    - <details><summary>Ответ:</summary>

        - `struct` (структура) - это составной тип данных в языке программирования C, который позволяет группировать
          переменные разных типов под одним именем. Структуры используются для представления записей, которые содержат
          несколько связанных полей.
        - Структура определяется с помощью ключевого слова `struct`, за которым следует список полей в фигурных скобках.
          Каждое поле имеет имя и тип данных. Например, вот как можно определить структуру для хранения информации о
          точке в двумерном пространстве:
        - ```c
          struct point {
            int x;
            int y;
          };
          ```
        - После определения структуры можно создавать переменные этого типа. Например:
        - ```c
          struct point p1;
          p1.x = 10;
          p1.y = 20;
          ```
        - Структуры могут быть переданы в функции и возвращены из функций. Они также могут быть элементами массивов и
          содержать другие структуры в качестве полей.
        - Структуры являются мощным инструментом для организации данных в программах на языке C.
     </details>

  ##### 50. Как определить размер структур?

    - <details><summary>Ответ:</summary>

        - В языке программирования C размер структуры можно определить с помощью оператора `sizeof`. Оператор `sizeof`
          возвращает размер в байтах объекта или типа, который передается ему в качестве аргумента. Например, чтобы
          определить размер структуры `point`, определенной выше, можно использовать следующий код:
        - ```c
          struct point { 
            int x;
            int y;
          };
        
          size_t size = sizeof(struct point);
          ```
      В этом примере переменная `size` будет содержать размер структуры `point` в байтах.
      Важно отметить, что размер структуры может быть больше суммы размеров ее полей из-за выравнивания памяти.
      Компилятор
      может добавлять дополнительные байты между полями или в конце структуры, чтобы удовлетворить требованиям
      выравнивания
      архитектуры компьютера. Поэтому размер структуры может зависеть от компилятора и архитектуры компьютера.

     </details>

  #### 51. Что такое выравнивание в структурах?

    - <details><summary>Ответ:</summary>

        - Выравнивание в структурах относится к расположению полей структуры в памяти. Некоторые архитектуры компьютеров
          имеют требования к выравниванию, которые определяют, как должны располагаться данные в памяти для эффективного
          доступа. Например, на многих архитектурах переменные типа `int` должны быть выровнены по границе 4 байт, то
          есть их адрес должен быть кратен 4.
        - Компиляторы автоматически учитывают требования к выравниванию при расположении полей структуры в памяти. Они
          могут добавлять дополнительные байты между полями или в конце структуры, чтобы удовлетворить требованиям
          выравнивания. Это может привести к тому, что размер структуры будет больше суммы размеров ее полей.
          Например, рассмотрим следующую структуру:
          ```c
            struct example {
              char a;
              int b;
            };
          ```
        - На архитектуре с требованием выравнивания переменных типа `int` по границе 4 байт компилятор может добавить 3
          дополнительных байта после поля `a`, чтобы поле `b` было выровнено по границе 4 байт. В этом случае размер
          структуры будет равен 8 байтам, а не 5 байтам (1 байт для поля `a` + 3 дополнительных байта + 4 байта для
          поля `b`).
        - Выравнивание может улучшить производительность программы за счет ускорения доступа к данным, но также может
          привести к увеличению размера структур и использованию большего количества памяти.
     </details>

  #### 52. Что такое union?

    - <details><summary>Ответ:</summary>

        - `union` - это тип данных в языке программирования C, который позволяет хранить разные типы данных в одном и
          том же блоке памяти. `union` похож на `struct`, но в отличие от `struct`, где каждое поле имеет свой
          собственный блок памяти, все поля `union` разделяют один и тот же блок памяти.
        - `union` определяется с помощью ключевого слова `union`, за которым следует список полей в фигурных скобках.
          Каждое поле имеет имя и тип данных. Например, вот как можно определить `union`, который может хранить целое
          число или число с плавающей точкой:
        - ```c
          union number {
            int i;
            float f;
          };
          ```
        - После определения `union` можно создавать переменные этого типа. Например:
        - ```c
          union number n;
          n.i = 10; // n хранит целое число
          n.f = 3.14; // теперь n хранит число с плавающей точкой
          ```
        - В этом примере переменная `n` может хранить либо целое число, либо число с плавающей точкой, но не оба
          одновременно. Когда мы присваиваем значение полю `f`, значение поля `i` становится неопределенным.
        - Размер `union` равен размеру самого большого поля. В примере выше размер `union number` будет равен размеру
          типа `float`, так как это самое большое поле.
        - `union` используется для экономии памяти, когда необходимо хранить разные типы данных, но не одновременно.
          Однако использование `union` требует осторожности, так как неправильное использование может привести к
          неопределенному поведению.
     </details>

  #### 53. Какой размер union?

    - <details><summary>Ответ:</summary>

        - Размер `union` в языке программирования C равен размеру самого большого поля в `union`. Поскольку все
          поля `union` разделяют один и тот же блок памяти, размер `union` должен быть достаточно большим, чтобы
          вместить самое большое поле.
        - Например, рассмотрим следующий `union`:
        - ```c
          union example {
            char c;
            int i;
            double d;
          };
          ```
        - В этом примере размер `union example` будет равен размеру типа `double`, так как это самое большое поле. На
          многих архитектурах размер типа `double` равен 8 байтам, поэтому размер `union example` будет равен 8 байтам.
        - Как и в случае со структурами, размер `union` может быть больше суммы размеров его полей из-за выравнивания
          памяти. Компилятор может добавлять дополнительные байты в конце `union`, чтобы удовлетворить требованиям
          выравнивания архитектуры компьютера. Поэтому размер `union` может зависеть от компилятора и архитектуры
          компьютера.
        - В языке программирования C размер `union` можно определить с помощью оператора `sizeof`, как и для любого
          другого типа данных. Например, чтобы определить размер `union example`, определенного выше, можно использовать
          следующий код:
        - ```c
          size_t size = sizeof(union example);
          ```
        - В этом примере переменная `size` будет содержать размер `union example` в байтах.
     </details>

----

- ### <span style="color:red">C++ OOP<span/>

  #### 54. Что такое класс?

    - <details><summary>Ответ:</summary>

        - Класс в C++ - это шаблон для создания объектов, который обеспечивает начальные значения состояний (
          инициализация
          полей-переменных) и реализацию поведения (функции или методы). Класс определяется с помощью ключевого слова
          class, за которым следует имя класса2. Тело класса определяется внутри фигурных скобок и заканчивается точкой
          с
          запятой в конце
    </details>

  #### 55. Какие есть основные типы данных в C++?

    - <details><summary>Ответ:</summary>

        - Основные типы данных в C++ включают:
            1. Целый тип (`int`)
            2. Символьный тип (`char`)
            3. Расширенный символьный тип (`wchar_t`)
            4. Логический тип (`bool`)
            5. Типы с плавающей точкой (`float`, `double` и `long double`)
            6. Тип `void`

            - Также есть составные типы, которые включают типы массивов, типы функций, типы классов (или структур), типы
              объединения, перечисления, ссылки и указатели на нестатические члены класса.
    </details>

  #### 56. Что такое инкапсуляция? Как она реализуется в C++?

    - <details><summary>Ответ:</summary>

        - Инкапсуляция - это сокрытие данных и методов в классе³. В языке C++ уровень доступности определяется с помощью
          специальных модификаторов `private`, `protected`, `public`³. Это позволяет ограничить доступ к данным и
          методам класса, чтобы обеспечить безопасность и предотвратить непреднамеренные изменения.
            1. [C++. Классы. Инкапсуляция. Модификаторы доступа private, protected. ](https://www.bestprog.net/ru/2020/11/08/c-access-modifiers-private-protected-public-encapsulating-data-in-a-class-ru/)
            2. [C++. Классы. Инкапсуляция. Модификаторы доступа private, protected.](https://bing.com/search?q=%d0%b8%d0%bd%d0%ba%d0%b0%d0%bf%d1%81%d1%83%d0%bb%d1%8f%d1%86%d0%b8%d1%8f+C%2b%2b)
            3. [Инкапсуляция в Си++ и Си / Хабр - Habr.](https://habr.com/ru/articles/444602/)
            4. [Инкапсуляция. Принципы ООП - Stack Overflow на русском.](https://ru.stackoverflow.com/questions/794196/%d0%98%d0%bd%d0%ba%d0%b0%d0%bf%d1%81%d1%83%d0%bb%d1%8f%d1%86%d0%b8%d1%8f-%d0%9f%d1%80%d0%b8%d0%bd%d1%86%d0%b8%d0%bf%d1%8b-%d0%9e%d0%9e%d0%9f)
            5. [Инкапсуляция - C++ - Киберфорум.](https://www.cyberforum.ru/cpp-beginners/thread2062534.html)
    </details>

  #### 57. Какие есть встроенные типы в С++?

    - <details><summary>Ответ:</summary>

        - Встроенные типы в C++ включают:
            1. Целый тип (`int`)
            2. Символьный тип (`char`)
            3. Расширенный символьный тип (`wchar_t`)
            4. Логический тип (`bool`)
            5. Типы с плавающей точкой (`float`, `double` и `long double`)
            6. Тип `void`
        - Эти типы задаются стандартом языка C++ и встроены в компилятор, то есть они не определены ни в одном файле
          заголовка.
    </details>

  #### 58. Что такое enum?

    - <details><summary>Ответ:</summary>

        - `enum` - это пользовательский тип данных, который может быть назначен ограниченному набору значений. Эти
          значения определяются программистом во время объявления перечисляемого типа². Значения `enum` являются
          значениями целочисленного типа, известного как базовый тип перечисления¹.
        - Синтаксис объявления `enum` выглядит следующим образом:
        - ```cpp
            enum имя_перечисляемого_типа { значение1, значение2, значение3, ... };
          ```
        - Например:
        - ```cpp
            enum ДниНедели { Понедельник, Вторник, Среда, Четверг, Пятница, Суббота, Воскресенье };
          ```
     </details>

  #### 59. Как соотносится класс и объект?

    - <details><summary>Ответ:</summary>

        - Класс в C++ - это шаблон для создания объектов, который обеспечивает начальные значения состояний (
          инициализация полей-переменных) и реализацию поведения (функции или методы). Объект - это экземпляр класса,
          который создается с помощью конструктора класса и имеет свои собственные значения для полей-переменных,
          определенных в классе. Объекты могут использовать методы, определенные в классе, для выполнения операций и
          изменения своего состояния.

    </details>

  #### 60. Какая разница между структурой и классом?

    - <details><summary>Ответ:</summary>

        - Структуры (`struct`) и классы (`class`) в C++ очень похожи. Оба используются для определения пользовательских
          типов данных с полями-переменными и методами. Однако есть одно ключевое отличие между ними: уровень доступа по
          умолчанию. В структурах уровень доступа по умолчанию для членов является `public`, а в классах - `private`.
          Это означает, что в структурах все члены доступны извне, если не указано иное, а в классах все члены скрыты,
          если не указано иное.
        - Например:
        - ```cpp
            struct MyStruct {
              int x; // public по умолчанию
            };
        
            class MyClass {
              int x; // private по умолчанию
            };
           ```
        - В остальном структуры и классы в C++ функционально эквивалентны. Хотите узнать больше?

    </details>

  #### 61. Разница между private/protected/public и где они используются?

    - <details><summary>Ответ:</summary>

        - `private`, `protected` и `public` являются модификаторами доступа в C++, которые используются для определения
          уровня доступа к членам класса или структуры.
        - `private`: Члены, объявленные как `private`, доступны только внутри самого класса и недоступны извне. Это
          означает, что они могут быть использованы только методами внутри класса.
        - `protected`: Члены, объявленные как `protected`, доступны внутри класса и его производных классов (классов,
          которые наследуются от него), но недоступны извне.
        - `public`: Члены, объявленные как `public`, доступны как внутри, так и снаружи класса. Это означает, что они
          могут быть использованы как методами внутри класса, так и кодом вне класса.
        - Например:
        - ```cpp
          class MyClass {
          private:
              int x; // доступен только внутри MyClass
          protected:
              int y; // доступен внутри MyClass и его производных классов
          public:
              int z; // доступен как внутри, так и снаружи MyClass
          };
          ```
        - Модификаторы доступа используются для инкапсуляции данных и методов в классе, чтобы обеспечить безопасность и
          предотвратить непреднамеренные изменения.
   </details>

  #### 62. Какие методы класса являются стандартными для класса?

    - <details><summary>Ответ:</summary>

        - В C++ есть несколько методов, которые являются стандартными для класса. Они называются специальными методами и
          включают:
        - Конструктор: метод, который вызывается при создании объекта класса. Он используется для инициализации
          полей-переменных объекта.
        - Деструктор: метод, который вызывается при уничтожении объекта класса. Он используется для освобождения
          ресурсов, занятых объектом.
        - Конструктор копирования: метод, который вызывается при создании нового объекта путем копирования существующего
          объекта.
        - Оператор присваивания: метод, который вызывается при присваивании одного объекта другому.
        - Оператор перемещения (C++11): метод, который вызывается при перемещении одного объекта в другой.

      Эти методы могут быть определены явно программистом или неявно сгенерированы компилятором.
    </details>

  #### 63. Что такое абстрактный класс и зачем он?

    - <details><summary>Ответ:</summary>

        - Абстрактный класс в C++ - это класс, который содержит хотя бы одну чисто виртуальную функцию. Чисто
          виртуальная функция - это виртуальная функция, которая не имеет определения в базовом классе и должна быть
          переопределена в производном классе. Абстрактные классы не могут быть инстанцированы, то есть нельзя создать
          объект абстрактного класса.
        - Абстрактные классы используются для определения общего интерфейса для группы связанных классов. Они позволяют
          создавать общий код для работы с объектами разных классов через указатель или ссылку на базовый абстрактный
          класс. Это упрощает код и делает его более гибким и расширяемым.
        - Например, предположим, что у нас есть несколько классов Cat, Dog и Bird, которые наследуются от абстрактного
          класса Animal. Абстрактный класс Animal может содержать чисто виртуальную функцию makeSound(), которая должна
          быть переопределена в каждом производном классе. Тогда мы можем написать код, который работает с объектами
          типа Animal и вызывает их метод makeSound(), не зная конкретного типа объекта.
        - В [этом примере](Codes/junior/jcode_63.cpp) код в функции main работает с массивом указателей на Animal и
          вызывает метод makeSound() для каждого объекта, не зная его конкретного типа.
    </details>

  #### 64. Сколько памяти занимает объект пустого класса class A {}; ?

    - <details><summary>Ответ:</summary>

        - Объект пустого класса class A {}; занимает 1 байт памяти. Это гарантируется стандартом C++, чтобы каждый
          объект имел уникальный адрес в памяти.
    </details>

  #### 65. Что случится с функцией, если к ней добавить ключевое слово static? В контексте члена класса? В контексте метода класса?

    - <details><summary>Ответ:</summary>

        - Ключевое слово `static` имеет разные значения в зависимости от контекста, в котором оно используется.
        - В контексте члена класса, `static` используется для объявления статического поля-переменной. Статическое
          поле-переменная является общей для всех объектов класса, а не уникальной для каждого объекта. Она
          инициализируется только один раз и сохраняет свое значение между вызовами функций.
        - В контексте метода класса, `static` используется для объявления статического метода. Статический метод не
          связан с конкретным объектом класса и может быть вызван без создания объекта. Он имеет доступ только к
          статическим полям-переменным и другим статическим методам класса.
        - [Например:](Codes/junior/jcode_65.cpp)

    </details>

  #### 66. Какие особенности статических полей класса?

    - <details><summary>Ответ:</summary>

        - Статические поля класса в C++ имеют несколько особенностей:
        - Они являются общими для всех объектов класса, а не уникальными для каждого объекта.
        - Они инициализируются только один раз, до начала выполнения программы, и сохраняют свое значение между вызовами
          функций.
        - Они могут быть доступны как внутри, так и снаружи класса, в зависимости от их модификатора доступа (`public`
          , `protected` или `private`).
        - Они должны быть определены вне класса, обычно в файле реализации (`.cpp`), с указанием их начального значения.
        - Они могут быть использованы как в статических, так и в нестатических методах класса.
        - В [этом примере](Codes/junior/jcode_66.cpp) `x` является статическим полем-переменной класса `MyClass`, а `y`
            - нестатическим полем-переменной. Изменение значения `x` через объект `obj1` отражается на значении `x` у
              объекта `obj2`, так как они оба ссылаются на одно и то же статическое поле-переменную.
    </details>

  #### 67. Какая особенность константных методов-членов класса?

    - <details><summary>Ответ:</summary>

        - Константные методы-члены класса в C++ - это методы, которые объявлены с ключевым словом `const` после списка
          параметров. Они имеют особенность того, что не могут изменять поля-переменные объекта, для которого
          вызываются.
        - Константные методы используются для определения операций, которые не изменяют состояние объекта. Они могут
          быть вызваны для константных и неконстантных объектов, но не могут вызывать неконстантные методы.
        - [Например:](Codes/junior/jcode_67.cpp)
        - В этом примере `nonConstMethod()` является неконстантным методом, а `constMethod()` - константным методом.
          Изменение значения поля-переменной `x` допустимо в `nonConstMethod()`, но недопустимо в `constMethod()`.
    </details>

  #### 68. Как изменить поле класса в константном методе класса?

    - <details><summary>Ответ:</summary>

        - В константном методе класса в C++ нельзя напрямую изменять поля-переменные объекта. Однако можно изменить
          поле, объявленное как `mutable`. Ключевое слово `mutable` используется для объявления поля-переменной, которое
          может быть изменено даже в константном методе.
        - [Например:](Codes/junior/jcode_68.cpp)
        - В этом примере `x` является неизменяемым полем-переменной, а `y` - изменяемым полем-переменной. Изменение
          значения `y` допустимо в константном методе `constMethod()`, но изменение значения `x` недопустимо.

    </details>

  #### 69. Какие методы можно вызвать из константных объектов?

    - <details><summary>Ответ:</summary>

        - Из константных объектов в C++ можно вызывать только константные методы. Константные методы - это методы,
          которые объявлены с ключевым словом `const` после списка параметров. Они не могут изменять поля-переменные
          объекта, для которого вызываются, и используются для определения операций, которые не изменяют состояние
          объекта.
        - [Например:](Codes/junior/jcode_69.cpp)
        - В этом примере `nonConstMethod()` является неконстантным методом, а `constMethod()` - константным методом.
          Вызов `nonConstMethod()` для константного объекта `constObj` недопустим, а вызов `constMethod()` для
          константного объекта `constObj` допустим.

    </details>

  #### 70. Что такое куча и стек? Различия, принцип работы.

    - <details><summary>Ответ:</summary>

        - Куча и стек - это два типа памяти, используемые в языках программирования, таких как C++. Стек используется
          для хранения локальных переменных и параметров, передаваемых в функции. Он работает как структура данных типа
          LIFO (последний вошел, первый вышел), где переменные добавляются и удаляются с вершины стека. Размер стека
          ограничен, и он не должен использоваться для хранения больших объемов данных.
        - Куча, с другой стороны, используется для динамического выделения памяти во время выполнения программы.
          Объекты, созданные с помощью оператора `new` в C++, располагаются в куче. Куча имеет больше места для хранения
          данных по сравнению со стеком, но выделение и освобождение памяти в куче может занимать больше времени.
        - Основное различие между кучей и стеком заключается в том, что стек используется для временного хранения
          данных, а куча - для долгосрочного хранения данных.

     </details>

  #### 71. В чем разница между указателем и ссылкой?

    - <details><summary>Ответ:</summary>

        - Указатель и ссылка в C++ - это два разных механизма доступа к переменным. Указатель - это переменная, которая
          хранит адрес другой переменной. Для доступа к значению, на которое указывает указатель, необходимо
          использовать оператор разыменования `*`. Ссылка же является псевдонимом для уже существующей переменной и не
          может быть изменена после инициализации[¹](https://www.geeksforgeeks.org/pointers-vs-references-cpp/).
        - Основные различия между указателями и ссылками:
            1. Указатель может быть переназначен, тогда как ссылка не
               может[¹](https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable)
               .
            2. Указатель может быть инициализирован значением `NULL`, тогда как ссылка не
               может[¹](https://www.geeksforgeeks.org/pointers-vs-references-cpp/).
            3. Указатель имеет свой собственный адрес в памяти, тогда как ссылка использует тот же адрес, что и исходная
               переменная¹.
            4. Можно иметь указатель на указатель, предлагающий дополнительные уровни косвенности, тогда как ссылки
               предлагают только один уровень косвенности[¹](https://www.geeksforgeeks.org/pointers-vs-references-cpp/).
        - В целом, указатели и ссылки используются для разных целей и имеют свои собственные преимущества и недостатки.
        - [1] [Pointers vs References in C++ GeeksforGeeks.]( https://www.geeksforgeeks.org/pointers-vs-references-cpp/)
        - [2] [c++ - What are the differences between a pointer](https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable)
   </details>

  #### 72. Для чего нужен указатель на функцию? Как его объявить?

    - <details><summary>Ответ:</summary>

        - Указатель на функцию в C++ используется для хранения адреса функции. Он может быть использован для вызова
          функции или передачи в качестве аргумента другой
          функции[³](https://www.educba.com/function-pointer-in-c-plus-plus/).
        - Чтобы объявить указатель на функцию, необходимо указать тип возвращаемого значения, имя указателя и типы
          параметров функции в круглых скобках. Например, чтобы объявить указатель на функцию, которая принимает два
          аргумента типа `int` и возвращает значение типа `int`, можно использовать следующий синтаксис:
        - ```c++
          int (*funcPtr)(int, int);
          ```
        - Чтобы инициализировать указатель на функцию, можно использовать оператор `&` для получения адреса функции и
          присвоить его указателю:
        - ```c++
          funcPtr = &myFunc;
          ```
        - Также можно вызвать функцию, используя указатель на
          нее[¹](https://www.geeksforgeeks.org/function-pointer-in-cpp/):
        - ```c++
          int result = funcPtr(4, 5);
          ```
     </details>

  #### 73. Что будет, если забыть вызвать delete? Когда освободится эта память?

    - <details><summary>Ответ:</summary>

        - Если вы забудете вызвать `delete` для освобождения памяти, выделенной с помощью `new`, это приведет к утечке
          памяти. Это означает, что память будет занята, но не будет использоваться вашей программой. Утечка памяти
          может привести к снижению производительности и другим
          проблемам[¹](https://stackoverflow.com/questions/14987318/what-happens-if-i-dont-delete).
        - Однако, когда ваша программа завершается, операционная система обычно автоматически освобождает всю память,
          выделенную для
          процесса[¹](https://stackoverflow.com/questions/1232262/memory-leak-in-c-c-forgot-to-do-free-delete). Это
          означает, что утечка памяти будет устранена после завершения программы. Однако
          это не означает, что можно игнорировать утечки памяти - хорошей практикой является всегда освобождать память с
          помощью `delete`, когда она больше не нужна.

    </details>

  #### 74. Что такое умный указатель? Какие умные указатели есть в стандартной библиотеке?

    - <details><summary>Ответ:</summary>

        - Умный указатель - это объект, который хранит указатель на динамически выделенный объект и управляет его
          жизненным циклом. Он автоматически освобождает память, когда объект больше не нужен, что помогает
          предотвратить утечки памяти и упрощает управление
          ресурсами[¹](https://en.cppreference.com/book/intro/smart_pointers).
        - В стандартной библиотеке C++ есть несколько типов умных указателей:
            1. `unique_ptr` - уникальный указатель, который обеспечивает эксклюзивное владение объектом. Он не может
               быть скопирован, но может быть перемещен.
            2. `shared_ptr` - разделяемый указатель, который использует подсчет ссылок для управления жизненным циклом
               объекта. Несколько `shared_ptr` могут указывать на один и тот же объект, и он будет удален только тогда,
               когда все `shared_ptr` будут уничтожены.
            3. `weak_ptr` - слабый указатель, который используется вместе с `shared_ptr` для предотвращения циклических
               ссылок. Он не увеличивает счетчик ссылок и не предотвращает удаление объекта.
        - Все эти типы умных указателей определены в заголовочном
          файле `<memory>`[¹](https://en.cppreference.com/book/intro/smart_pointers).

    </details>

  #### 75. Как работает std::unique_ptr?

    - <details><summary>Ответ:</summary>

        - `std::unique_ptr` - это умный указатель, который обеспечивает эксклюзивное владение объектом. Он хранит
          указатель на динамически выделенный объект и автоматически удаляет его, когда `std::unique_ptr` уничтожается.
          Это помогает предотвратить утечки памяти и упрощает управление ресурсами.
        - Одним из ключевых свойств `std::unique_ptr` является то, что он не может быть скопирован. Это гарантирует, что
          только один `std::unique_ptr` владеет объектом в любой момент времени. Однако `std::unique_ptr` может быть
          перемещен с помощью move-семантики, что позволяет передать владение объектом другому `std::unique_ptr`.
        - `std::unique_ptr` также предоставляет набор методов для управления объектом, таких как `reset`, который
          позволяет заменить текущий объект новым, и `release`, который позволяет отказаться от владения объектом без
          его удаления. ё
        - Вот простой пример использования `std::unique_ptr`:
        - ```c++
           
           #include <memory>
           #include <iostream>
        
           int main() {
               std::unique_ptr<int> ptr(new int(5));
               std::cout << *ptr << std::endl; // выводит 5
               ptr.reset(new int(10));
               std::cout << *ptr << std::endl; // выводит 10
           }
          ```
        - В [этом примере](https://github.com/Jollu8/Algorithms/blob/main/SmartPointes/UniquePtr.cpp) мы
          создаем `std::unique_ptr`, который владеет динамически выделенным объектом типа `int`. Затем
          мы используем метод `reset` для замены этого объекта новым. Когда вызывается `reset`, старый объект
          автоматически удаляется.
     </details>

  #### 76. Как работает std::shared_ptr?

    - <details><summary>Ответ:</summary>

        - `std::shared_ptr` - это умный указатель, который использует подсчет ссылок для управления жизненным циклом
          объекта. Это означает, что несколько `shared_ptr` могут указывать на один и тот же объект, и он будет удален
          только тогда, когда все `shared_ptr`, указывающие на него, будут уничтожены.
        - Когда вы создаете `shared_ptr`, он увеличивает счетчик ссылок на объект. Когда `shared_ptr` уничтожается, он
          уменьшает счетчик ссылок. Если счетчик ссылок достигает нуля, это означает, что больше нет `shared_ptr`,
          указывающих на объект, и он может быть безопасно удален.
        - `std::shared_ptr` также предоставляет набор методов для управления объектом, таких как `reset`, который
          позволяет заменить текущий объект новым, и `use_count`, который возвращает текущее количество `shared_ptr`,
          указывающих на объект.
        - Вот простой пример использования `std::shared_ptr`:
        - ```c++
          #include <memory>
          #include <iostream>
          int main() {
             std::shared_ptr<int> ptr1(new int(5));
             std::cout << *ptr1 << std::endl; // выводит 5
             std::cout << ptr1.use_count() << std::endl; // выводит 1
          {
          std::shared_ptr<int> ptr2 = ptr1;
          std::cout << ptr1.use_count() << std::endl; // выводит 2
           }
           std::cout << ptr1.use_count() << std::endl; // выводит 1
          }
          ```
        - В этом примере мы создаем `std::shared_ptr`, который владеет динамически выделенным объектом типа `int`. Затем
          мы создаем еще один `shared_ptr`, который указывает на тот же объект. Когда второй `shared_ptr` выходит из
          области видимости и уничтожается, счетчик ссылок уменьшается, но объект не удаляется, потому что все еще есть
          другой `shared_ptr`, указывающий на него.

        - [Мой исходный код](https://github.com/Jollu8/Algorithms/blob/main/SmartPointes/SharedPtr.cpp)
    </details>

  #### 77. Расскажите о константности переменной, ссылки, указателя. Что такое константный указатель и указатель на константу? Размер указателя в памяти?

    - <details><summary>Ответ:</summary>

        - Константность в C++ используется для обозначения того, что значение переменной не может быть изменено. Это
          достигается с помощью ключевого слова `const`. Например, чтобы объявить константную переменную типа `int`,
          можно использовать следующий синтаксис:
        - ```c++
             const int x = 5;
          ```
        - После объявления константной переменной ее значение не может быть изменено.
        - Константность также может быть применена к ссылкам и указателям. Константная ссылка - это ссылка, которая не
          может быть использована для изменения значения переменной, на которую она указывает. Например:
        - ```c++
          int x = 5;
          const int& ref = x;
          ref = 10; // Ошибка: нельзя изменить значение через константную ссылку
          ```
        - Константный указатель - это указатель, который не может быть изменен после инициализации. Это означает, что он
          всегда будет указывать на один и тот же адрес в памяти. Например:
        - ```c++
          int x = 5;
          int y = 10;
          int* const ptr = &x;
          ptr = &y; // Ошибка: нельзя изменить значение константного указателя
          ```
        - Указатель на константу - это указатель, который указывает на константное значение. Это означает, что значение,
          на которое указывает указатель, не может быть изменено через этот указатель. Например:
        - ```c++
          int x = 5;
          const int* ptr = &x;
          *ptr = 10; // Ошибка: нельзя изменить значение через указатель на константу
          ```
        - Размер указателя в памяти зависит от аппаратной архитектуры и операционной системы. На 32-битных системах
          размер указателя обычно равен 4 байтам, а на 64-битных системах - 8 байтам. Однако это не является строгим
          правилом, и размер указателя может отличаться в зависимости от конкретной системы.

    </details>

  #### 78. Расскажите о передаче аргументов по значению, по ссылке и по указателю.

    - <details><summary>Ответ:</summary>

        - В C++ есть три способа передачи аргументов в функцию: по значению, по ссылке и по указателю.
        - **Передача по значению** означает, что когда вы передаете аргумент в функцию, создается его копия, и функция
          работает с этой копией. Изменения, внесенные в копию внутри функции, не затрагивают исходный аргумент.
          Например:
        - ```c++
           void increment(int x) {
            x++;
          }
        
          int main() {
            int a = 5;
            increment(a);
            std::cout << a << std::endl; // выводит 5
          }
          ```
          В этом примере функция `increment` принимает аргумент `x` по значению. Когда мы вызываем эту функцию и
          передаем ей переменную `a`, создается копия `a`, и функция работает с этой копией. Изменения, внесенные в
          копию внутри функции, не затрагивают исходную переменную `a`.
        - **Передача по ссылке** означает, что когда вы передаете аргумент в функцию, передается ссылка на этот
          аргумент, и функция работает непосредственно с исходным аргументом. Изменения, внесенные в аргумент внутри
          функции, затрагивают исходный аргумент. Например:
        - ```c++
           void increment(int& x) {
            x++;
           }
        
           int main() {
            int a = 5;
            increment(a);
            std::cout << a << std::endl; // выводит 6
          }
          ```
        - В этом примере функция `increment` принимает аргумент `x` по ссылке. Когда мы вызываем эту функцию и передаем
          ей переменную `a`, передается ссылка на `a`, и функция работает непосредственно с переменной `a`. Изменения,
          внесенные в `a` внутри функции, затрагивают исходную переменную.
        - **Передача по указателю** похожа на передачу по ссылке, но использует указатели вместо ссылок. Когда вы
          передаете аргумент в функцию по указателю, передается указатель на этот аргумент, и функция работает
          непосредственно с исходным аргументом через указатель. Например:
        - ```c++
           void increment(int* x) {
            (*x)++;
           }
        
           int main() {
            int a = 5;
            increment(&a);
            std::cout << a << std::endl; // выводит 6
           }
           ```
        - В этом примере функция `increment` принимает аргумент `x` по указателю. Когда мы вызываем эту функцию и
          передаем ей адрес переменной `a`, передается указатель на `a`, и функция работает непосредственно с
          переменной `a` через указатель. Изменения, внесенные в `a` внутри функции, затрагивают исходную переменную.
     </details>

  #### 79. Расскажите о порядке вычисления аргументов функции?

    - <details><summary>Ответ:</summary>

        - В C++ порядок вычисления аргументов функции не определен. Это означает, что компилятор может вычислять
          аргументы в любом порядке, и этот порядок может отличаться от вызова к вызову. Например, рассмотрим следующую
          функцию:
        - ```c++
          void foo(int a, int b, int c) {
              // ...
          }
          ```

        - И предположим, что мы вызываем эту функцию следующим образом:
        - ```c++
          foo(x(), y(), z());
          ```

        - В этом случае компилятор может вычислить аргументы в порядке `x()`, `y()`, `z()`, или в порядке `z()`, `y()`
          , `x()`, или в любом другом порядке. Порядок вычисления аргументов не определен.
        - Это может привести к неожиданным результатам, если вычисление одного аргумента зависит от другого. Например,
          рассмотрим следующий код
        - ```c++
          int i = 0;
          void foo(int a, int b) {
               std::cout << a << " " << b << std::endl;
          }
          int bar() {
              i++;
              return i;
          }
          
          int main() {
              foo(bar(), bar());
          }
          ```

        - В этом примере мы вызываем функцию `foo` с двумя аргументами, каждый из которых является результатом вызова
          функции `bar`. Однако, поскольку порядок вычисления аргументов не определен, мы не можем точно сказать, какой
          будет вывод этого кода. Он может быть `1 2` или `2 1`, в зависимости от того, в каком порядке компилятор
          вычисляет аргументы.
        - Таким образом, важно избегать зависимостей между аргументами функции и убедиться, что порядок их вычисления не
          имеет значения для корректности программы.
    </details>

  #### 80. Что произойдет, если вернуть ссылку на временный объект?

    - <details><summary>Ответ:</summary>

        - Возвращение ссылки на временный объект является ошибкой, которая может привести к неопределенному поведению.
          Временные объекты уничтожаются в конце выражения, в котором они были созданы. Если вы возвращаете ссылку на
          временный объект, то ссылка будет указывать на уничтоженный объект, и попытка доступа к нему может привести к
          ошибкам.
        - Например, рассмотрим следующий код:
        - ```c++
          #include <iostream>
          int& foo() {
            int x = 5;
            return x;
          }
          int main() {
            int& y = foo();
            std::cout << y << std::endl;
          ```

        - В этом примере функция `foo` возвращает ссылку на локальную переменную `x`. Однако, когда функция завершается,
          переменная `x` уничтожается, и ссылка `y` в функции `main` указывает на уничтоженный объект. Попытка доступа к
          этому объекту через ссылку `y` может привести к неопределенному поведению. Чтобы избежать этой ошибки,
          необходимо убедиться, что ссылка возвращается только на объекты, которые существуют после завершения функции.
          Это могут быть глобальные переменные, статические локальные переменные или объекты, выделенные в динамической
          памяти.
    </details>

  #### 81. Что такое перегрузки функции? Виды перегрузки.

    - <details><summary>Ответ:</summary>

        - Перегрузка функций в C++ позволяет иметь несколько функций с одинаковым именем, но с разными параметрами.
          Компилятор выбирает правильную версию функции для вызова на основе типов и количества передаваемых аргументов.
        - Например, рассмотрим следующий код:
        - ```c++
           #include <iostream>
           void print(int x) {
           std::cout << "int: " << x << std::endl;
      
           void print(double x) {
               std::cout << "double: " << x << std::endl;
           }
           void print(const char* x) {
           std::cout << "const char*: " << x << std::endl;
           }
           int main() {
           print(5);
           print(5.0);
           print("Hello");
           }
          ```

        - В этом примере мы имеем три перегруженные версии функции `print`, каждая из которых принимает разные типы
          аргументов. Когда мы вызываем функцию `print` в функции `main`, компилятор выбирает правильную версию функции
          на
          основе типа передаваемого аргумента.

        - Перегрузка функций может быть полезна, когда необходимо обеспечить одинаковое поведение для разных типов
          данных.
          Она позволяет создавать более универсальный и легко читаемый код.
            1. Однако, есть несколько правил, которые необходимо соблюдать при перегрузке функций:
            2. Перегруженные функции должны отличаться по типам или количеству параметров.
            3. Перегруженные функции не могут отличаться только по типу возвращаемого значения.

            4. Порядок параметров также имеет значение: функция, принимающая `int` и `double`, считается отдельной от
               функции, принимающей `double` и `int`.
    </details>

  #### 82. Что такое явное и неявное приведение типов в С++? Расскажите о функциях явного приведения типов в C++.

    - <details><summary>Ответ:</summary>

        - Приведение типов в C++ используется для преобразования значения одного типа данных в значение другого типа
          данных. В C++ есть два вида приведения типов: явное и неявное.
        - **Неявное приведение типов** происходит автоматически, когда компилятор пытается присвоить значение одного
          типа переменной другого типа или передать значение одного типа в функцию, ожидающую другой тип. Например:
        - ```c++
          int x = 5;
          double y = x; // неявное приведение типа int к double
          ```

        - В этом примере переменная `x` имеет тип `int`, а переменная `y` имеет тип `double`. Когда мы присваиваем
          значение `x` переменной `y`, компилятор автоматически преобразует значение `x` из `int` в `double`.
        - **Явное приведение типов** используется, когда необходимо явно указать компилятору, какой тип должен быть
          преобразован в какой. В C++ есть несколько способов выполнения явного приведения типов, включая C-стиль
          приведения и функции приведения типов C++.
        - C-стиль приведения выполняется с помощью круглых скобок и имени целевого типа:
        - ```c++
          int x = 5;
          double y = (double)x; // явное приведение типа int к double
          ```

        - В этом примере мы явно указываем компилятору, что значение `x` должно быть преобразовано из `int` в `double`.

        - Функции приведения типов C++ предоставляют более безопасный и удобный способ выполнения явного приведения
          типов. В C++ есть четыре функции приведения типов: `static_cast`, `dynamic_cast`, `const_cast`
          и `reinterpret_cast`.`static_cast` используется для выполнения обычных преобразований типов, таких как
          преобразование целочисленных типов в числа с плавающей точкой и наоборот:
        - ```c++
          int x = 5;
          double y = static_cast<double>(x); // явное приведение типа int к double
          ```

        - `dynamic_cast` используется для безопасного преобразования указателей и ссылок на базовые и производные классы
          в иерархии наследования.
        - `const_cast` используется для изменения константности или volatile-свойства объекта.
        - `reinterpret_cast` используется для выполнения низкоуровневых преобразований, таких как преобразование
          указателя в целое число или наоборот.
    </details>

  #### 83. Что такое инициализация переменной в if?

    - <details><summary>Ответ:</summary>

        - Инициализация переменной в if - это функция, добавленная в C++17, которая позволяет объявлять и
          инициализировать переменную непосредственно в условном выражении if. Эта переменная существует только в
          области видимости if и else блоков.
        - В этом [примере](Codes/junior/jcode_83.cpp) мы используем инициализацию переменной в if для объявления и
          инициализации переменной it непосредственно в условном выражении if. Переменная it существует только в области
          видимости if и else блоков, и мы можем использовать ее для доступа к данным, найденным с помощью метода find.
          Инициализация переменной в if может быть полезна, когда необходимо объявить переменную для использования
          только внутри if или else блоков. Она позволяет сделать код более чистым и удобным для чтения.
    </details>

  #### 84. Что такое ленивые вычисления в С++?

    - <details><summary>Ответ:</summary>

        - Ленивые вычисления (lazy evaluation) - это стратегия вычисления, при которой вычисление выражения
          откладывается до тех пор, пока его результат не потребуется. Это может привести к улучшению
          производительности, поскольку избегается вычисление ненужных значений.
        - В C++ нет встроенной поддержки ленивых вычислений, но их можно реализовать с помощью различных техник.
          Например, можно использовать лямбда-выражения и функции высшего порядка для создания ленивых вычислений. Вот
          простой пример:
        - ```c++
          #include <iostream>
          #include <functional>
          int main() {
              std::function<int()> lazy_pow = []() {
                 std::cout << "Computing 2^2..." << std::endl;
                 return 2 * 2;
              };
              std::cout << "Before calling lazy_pow" << std::endl;
              int result = lazy_pow();
              std::cout << "After calling lazy_pow: " << result << std::endl;
          }
          ```

        - В этом примере мы создаем лямбда-выражение, которое вычисляет значение `2^2`, и присваиваем его
          переменной `lazy_pow`. Вычисление значения откладывается до тех пор, пока мы не вызовем `lazy_pow`. Когда мы
          вызываем `lazy_pow`, лямбда-выражение выполняется и возвращает результат. Этот подход может быть полезен,
          когда вычисление значения занимает много времени или ресурсов, и мы хотим отложить его до тех пор, пока
          результат действительно не потребуется.
    </details>

  #### 85. Расскажите о циклах for и range-for.

    - <details><summary>Ответ:</summary>

        - Цикл `for` в C++ используется для повторения набора инструкций определенное количество раз. Он имеет следующий
          синтаксис:
        - ```c++
          for (initialization; condition; increment) { 
              // тело цикла
          }
          ```

        - В начале цикла выполняется инициализация. Затем проверяется условие. Если условие истинно, выполняется тело
          цикла, а затем выполняется инкремент. Этот процесс повторяется до тех пор, пока условие остается истинным.
          Когда условие становится ложным, цикл завершается.
        - Например, вот как можно использовать цикл `for` для вывода чисел от 1 до 5:
        - ```c++
          #include <iostream>
          int main() {
              for (int i = 1; i <= 5; i++) {
                  std::cout << i << std::endl;
              }
          }
          ```

        - В этом примере мы инициализируем переменную `i` значением 1, а затем проверяем, что `i` меньше или равно 5.
          Если это так, мы выводим значение `i`, увеличиваем его на 1 и повторяем процесс. Когда `i` становится больше
          5, цикл завершается. Цикл `range-for` (или цикл по диапазону) - это функция, добавленная в C++11, которая
          позволяет итерировать по элементам контейнера или другого диапазона значений. Он имеет следующий синтаксис:
        - ```c++
          for (declaration : range) { 
             // тело цикла
          }
          ```

        - В этом случае `declaration` объявляет переменную, которая будет использоваться для доступа к текущему элементу
          диапазона на каждой итерации цикла. `range` - это выражение, представляющее диапазон значений, по которым
          нужно итерировать.
        - Например, вот как можно использовать цикл `range-for` для вывода элементов массива:
        - ```c++
          #include <iostream>
          int main() {
              int data[] = {1, 2, 3, 4, 5};
              for (int x : data) {
                 std::cout << x << std::endl;
              }
          }
          ```

        - В этом примере мы используем цикл `range-for` для итерации по элементам массива `data`. На каждой итерации
          переменная `x` принимает значение текущего элемента массива, и мы можем использовать ее в теле цикла для
          доступа к этому элементу.
    </details>

  #### 86. Что делает ключевое слово auto? auto-определение return-типа, аргументов функции?

    - <details><summary>Ответ:</summary>

        - Ключевое слово `auto` в C++ используется для автоматического определения типа переменной на основе ее
          инициализатора. Компилятор вычисляет тип инициализатора и использует его в качестве типа переменной. Например:
        - ```c++
          auto x = 5; // тип x - int
          auto y = 5.0; // тип y - double
          ```

        - В этом примере мы используем ключевое слово `auto` для объявления переменных `x` и `y`. Компилятор вычисляет
          типы их инициализаторов (целое число и число с плавающей точкой соответственно) и использует их в качестве
          типов переменных.
        - Ключевое слово `auto` также может использоваться для автоматического определения типа возвращаемого значения
          функции, если оно указано с помощью `decltype(auto)` или в лямбда-выражениях. Например:
        - ```c++
          #include <iostream>
          int add(int x, int y) {
              return x + y;
          }
          int main() {
              auto result = add(5, 3);
              std::cout << result << std::endl;
          }
          ```

        - В этом примере мы используем ключевое слово `auto` для объявления переменной `result`, которая хранит
          результат вызова функции `add`. Компилятор вычисляет тип возвращаемого значения функции `add` (в данном
          случае `int`) и использует его в качестве типа переменной `result`. Однако, ключевое слово `auto` не может
          использоваться для автоматического определения типов аргументов функции. Типы аргументов функции должны быть
          явно указаны при объявлении функции.
     </details>

  #### 87. Чем отличаются delete и delete [ ] ? Что случится, если вызвать delete у объекта, созданного через new [ ] ?

    - <details><summary>Ответ:</summary>

        - Операторы `delete` и `delete[]` в C++ используются для освобождения памяти, выделенной с помощью
          операторов `new` и `new[]` соответственно. Оператор `delete` используется для освобождения памяти, выделенной
          для одного объекта, а оператор `delete[]` - для освобождения памяти, выделенной для массива объектов.
        - Например, рассмотрим следующий код:
        - ```c++
          int* x = new int;
          delete x;
          int* y = new int[5];
          delete[] y;
          ```

        - В этом примере мы выделяем память для одного объекта типа `int` с помощью оператора `new` и освобождаем ее с
          помощью оператора `delete`. Затем мы выделяем память для массива из 5 объектов типа `int` с помощью
          оператора `new[]` и освобождаем ее с помощью оператора `delete[]`.
        - Если вы используете неправильный оператор для освобождения памяти (например, используете `delete`
          вместо `delete[]`), это может привести к неопределенному поведению, такому как повреждение кучи или утечка
          памяти. Например:
        - ```c++
          int* y = new int[5];
          delete y; // Ошибка: должно быть delete[]
          ```

        - В этом примере мы выделяем память для массива из 5 объектов типа `int`, но затем ошибочно используем
          оператор `delete` вместо `delete[]` для освобождения памяти. Это может привести к неопределенному поведению.
          Таким образом, важно всегда использовать правильный оператор для освобождения памяти: `delete` для памяти,
          выделенной с помощью `new`, и `delete[]` для памяти, выделенной с помощью `new[]`.

    </details>

  #### 88. Обработка ошибок в С++. Каки конструкции используют при обработке exception?

    - <details><summary>Ответ:</summary>

        - В C++ для обработки ошибок используются исключения (exceptions). Исключения позволяют обнаруживать ошибки во
          время выполнения программы и передавать информацию об ошибках вверх по стеку вызовов до тех пор, пока она не
          будет обработана.
        - Для генерации исключения используется оператор `throw`. Он принимает в качестве аргумента значение, которое
          представляет информацию об ошибке. Это значение может быть любого типа, но обычно используются специальные
          классы исключений, определенные в стандартной библиотеке или созданные пользователем.
        - Для обработки исключений используются блоки `try`/`catch`. Блок `try` содержит код, который может генерировать
          исключения. Блок `catch` содержит код, который обрабатывает исключения. Например:
        - В этом [примере](Codes/junior/jcode_88.cpp) функция `divide` генерирует исключение типа `std::runtime_error`,
          если ее второй аргумент равен нулю. В функции `main` мы вызываем функцию `divide` внутри блока `try` и
          обрабатываем возможные исключения в блоке `catch`. Если функция `divide` генерирует исключение, выполнение
          переходит в блок `catch`, где мы можем обработать ошибку.
        - В блоке `catch` можно указать тип исключения, которое нужно обработать. Если тип сгенерированного исключения
          совпадает с типом, указанным в блоке `catch`, то выполнение переходит в этот блок. Можно указать несколько
          блоков `catch` с разными типами исключений для обработки разных ошибок.
        - Также можно использовать специальный блок `catch (...)`, который перехватывает все исключения, независимо от
          их типа. Однако этот подход следует использовать с осторожностью, поскольку он может скрыть ошибки, которые
          должны быть обработаны отдельно.
    </details>

  #### 89. Можно ли выбрасывать exception из конструктора? Какие поля будут сконструированы, какие поля будут разрушены?

    - <details><summary>Ответ:</summary>

        - Да, можно выбрасывать исключения из конструктора в C++. Если конструктор неудачно завершается и выбрасывает
          исключение, то деструктор объекта не будет вызван, но будут вызваны деструкторы для уже созданных полей класса
    </details>

  #### 90. Что такое memory leak?

    - <details><summary>Ответя:</summary>

        - `Memory leak` - это тип утечки ресурсов, который происходит, когда компьютерная программа неправильно
          управляет выделением памяти таким образом, что память, которая больше не нужна, не освобождается . Это может
          привести к истощению доступной системной памяти по мере работы приложения, что может вызвать снижение
          производительности компьютера или даже сбои в работе программы или системы.
        - <img src="Images/img_90_1.png">

    </details>

  #### 91. Можно ли выбрасывать exception из деструктора?

    - <details><summary>Ответ:</summary>

        - Выбрасывание исключения из деструктора может привести к неопределенному поведению . После C++11 деструкторы по
          умолчанию помечены как noexcept, и это вызовет terminate, если исключение выходит за пределы деструктора
      </details>

  #### 92. Как отловить деление на 0 в С++?

    - <details><summary>Ответ:</summary>

        - Деление на ноль в С++ является неопределенным поведением и не может быть отловлено с помощью `try/catch`.
          Однако, вы можете проверить знаменатель перед делением и обработать эту ситуацию соответствующим образом.
     </details>

  #### 93. Как работают константные методы?

    - <details><summary>Ответ:</summary>

        - Константные методы используются для определения того, что можно сделать с классом без побочного действия на
          его состояние и что изменяет его состояние. Это позволяет пользователю класса, в котором правильно расставлены
          const, в некоторых случаях избежать лишнего копирования объектов без потери данных. Также при правильном
          использовании const на уровне компиляции исключается случайное изменение объекта в методе, который не должен
          ничего в объекте менять.
    </details>

  #### 94. Что такое лямбда-функция в С++? Как получить доступ к переменным во внешней области видимости?

    - <details><summary>Ответ:</summary>

        - Лямбда-функция в С++ - это безымянная функция, которую можно использовать как локальную функцию внутри блока
          кода. Она может захватывать переменные из внешней области видимости и использовать их в своем теле. Вот
          пример:
        - ```cpp
          #include <iostream>
          #include <vector>
          #include <algorithm>
          int main() {
              std::vector<int> numbers = {1, 2, 3, 4, 5};
              int sum = 0;
              std::for_each(numbers.begin(), numbers.end(), [&sum](int x) { sum += x; });
              std::cout << "Sum: " << sum << std::endl;
          }
          ```

        - В этом примере мы используем лямбда-функцию в качестве третьего аргумента для алгоритма `for_each`.
          Лямбда-функция захватывает переменную `sum` из внешней области видимости по ссылке (обозначается с
          помощью `[&sum]`) и использует ее в своем теле для вычисления суммы элементов вектора. Вы можете захватывать
          переменные по ссылке (с помощью `&`) или по значению (с помощью `=`). Вы также можете использовать `[&]` для
          захвата всех переменных по ссылке или `[=]` для захвата всех переменных по значению.
    </details>

  #### 95. Для чего использовать namespace, anonymous namespace?

    - <details><summary>Ответ:</summary>

        - Пространства имен используются для организации кода в виде логических групп и с целью избежания конфликтов
          имен, которые могут возникнуть, особенно в таких случаях, когда база кода включает несколько библиотек .
        - Анонимные пространства имен позволяют ограничить область действия того, что находится внутри него, только
          текущим файлом. Это может быть сделано программистом, чтобы избежать конфликтов имен . Таким образом,
          анонимные пространства имен позволяют убедиться, что никакие глобальные имена не будут конфликтовать,
          поскольку имена функций в каждом пространстве имен имеют приоритет над внешними именами функций
      </details>

  #### 96. Как вызвать объект из nested namespace?

    - <details><summary>Ответ:</summary>

        - Да, пространства имен могут быть вложенными в C++, и разрешение переменных пространства имен является
          иерархическим . Чтобы вызвать объект из вложенного пространства имен, вы можете использовать оператор
          разрешения области видимости `::` для указания полного пути к объекту. Например, если у вас есть вложенное
          пространство имен `outer::inner`, то вы можете вызвать объект `myObject` из этого пространства имен,
          используя `outer::inner::myObject`.

    </details>

  #### 97. Как работают inline-функции? Может ли такая функция быть рекурсивной?

    - <details><summary>Ответ:</summary>

        - Inline-функции - это функции, которые компилятор пытается вставить непосредственно в код вызывающей программы,
          чтобы уменьшить накладные расходы на вызов функций. Это означает, что вместо того, чтобы генерировать
          инструкции для вызова функции и возврата из нее, компилятор пытается заменить вызов функции на ее фактический
          код . Да, inline-функция может быть рекурсивной. Однако, если функция является рекурсивной и не
          имеет `#pragma inline_recursion(on)` заданного значения, то компилятор может не выполнять подстановку
          рекурсивных функций.

   </details>

  #### 98. Что такое полиморфизм?

    - <details><summary>Ответ:</summary>

        - Полиморфизм в C++ - это концепция, которая позволяет обрабатывать объекты разных типов так, как если бы они
          были одного типа, и по-разному реагировать на одни и те же методы
          или [функции](https://vertex-academy.com/tutorials/ru/chto-takoe-polimorfizm-java/). Это означает, что вызов
          функции-члена вызовет выполнение другой функции в зависимости от типа объекта, который вызывает эту
          функцию [¹](https://highload.today/polymorphism/).
        - Полиморфизм позволяет упростить код с помощью абстракции и обеспечивает гибкость и расширяемость программного
          обеспечения. Он может быть достигнут с помощью использования виртуальных функций и наследования.
    </details>

  #### 99. Для чего используется наследование?

    - <details><summary>Ответ:</summary>

        - Наследование в программировании - это механизм, который позволяет создавать новые классы на основе уже
          существующих классов, повторно используя, расширяя и изменяя их поведение 1. Это позволяет уменьшить
          дублирование кода и упростить его поддержку 2.
        - Наследование также способствует независимому расширению программного обеспечения через открытые классы и
          интерфейсы 3. Оно позволяет создавать более специализированные классы, которые наследуют общие свойства и
          методы от базового класса, а затем добавляют или переопределяют их для реализации более специфического
          поведения.
    </details>

  #### 100. Какие бывают типы наследования?

    - <details><summary>Ответ:</summary>

        - В C++ существует несколько типов наследования, которые определяют уровень доступа к членам базового класса в
          производном классе. Они включают:
            1. **Публичное наследование (public)**: при этом типе наследования все публичные и защищенные члены базового
               класса
               становятся соответственно публичными и защищенными членами производного класса. Это наиболее
               распространенный тип
               наследования.
            2. **Защищенное наследование (protected)**: при этом типе наследования все публичные и защищенные члены
               базового класса
               становятся защищенными членами производного класса.

            3. **Приватное наследование (private)**: при этом типе наследования все публичные и защищенные члены
               базового класса
               становятся приватными членами производного класса.
               Тип наследования определяется в объявлении производного класса с помощью ключевых слов `public`
               , `protected`
               или `private`. Если тип наследования не указан явно, то по умолчанию используется приватное наследование.

        - <img src="Images/img_100_1.png">

    </details>

  #### 101. Для чего используют виртуальное наследование?

    - <details><summary>Ответ:</summary>

        - Виртуальное наследование используется в C++ для решения проблемы, которая может возникнуть при множественном
          наследовании, когда один и тот же базовый класс наследуется несколько раз через разные пути иерархии
          наследования. Эта проблема называется **ромбовидным наследованием** ¹.
        - Виртуальное наследование позволяет производному классу наследовать только один экземпляр общего базового
          класса, что устраняет неоднозначность и позволяет избежать дублирования данных ². Для этого в объявлении
          класса используется ключевое слово `virtual` перед указанием базового класса.
        - Например, [предположим](Codes/junior/jcode_101.cpp), что у нас есть базовый класс `Animal`, от которого
          наследуются два класса `Mammal`
          и `WingedAnimal`. Затем мы создаем класс `Bat`, который наследует от обоих этих классов. Без виртуального
          наследования в объекте класса `Bat` будет два экземпляра класса `Animal`, что может привести к неоднозначности
          и дублированию данных. Чтобы избежать этого, мы можем использовать виртуальное наследование при объявлении
          классов `Mammal` и `WingedAnimal`:
        - Теперь в объекте класса `Bat` будет только один экземпляр класса `Animal`, что позволит избежать
          неоднозначности и дублирования данных.

   </details>

  #### 102. Как можно решить проблему ромбовидного наследования без использования виртуального наследования?

    - <details><summary>Овтет:</summary>

        - Проблему ромбовидного наследования можно решить несколькими способами, помимо использования виртуального
          наследования. Один из них - это изменение иерархии наследования, чтобы избежать множественного наследования от
          одного и того же базового класса. Это может быть достигнуто путем переорганизации классов или использования
          композиции вместо наследования.
        - Например, вместо того, чтобы создавать класс `Bat`, который наследует от классов `Mammal` и `WingedAnimal`,
          которые оба наследуют от класса `Animal`, можно создать класс `WingedMammal`, который наследует от
          класса `Mammal` и добавляет функциональность крыльев. Затем класс `Bat` может наследовать только от
          класса `WingedMammal`. Это позволит избежать ромбовидного наследования.
        - ```c++
          class Animal {
          public: 
               virtual void eat();
               ...
          };
          class Mammal : public Animal {
          public:
              Color getHairColor();
              ...
          };
          class WingedMammal : public Mammal {
          public:
              void flap();
              ...
          };
          class Bat : public WingedMammal {};
          ```

        - Также можно использовать композицию, чтобы добавить функциональность крыльев к классу `Bat`, вместо
          использования наследования. Например, можно создать класс `Wings`, который содержит всю необходимую
          функциональность, а затем добавить объект этого класса как член в класс `Bat`.
        - ```c++
          class Animal {
          public:
              virtual void eat();
              ...
          };
          class Mammal : public Animal {
          public:
              Color getHairColor();
              ...
          };
          class Wings {
          public:
              void flap();
              ...
          };
          class Bat : public Mammal {
          public:
               Wings wings;
          };
          ```

        - В этом случае класс `Bat` наследует только от класса `Mammal`, но также имеет доступ к функциональности
          крыльев через объект класса `Wings`. Это также позволяет избежать ромбовидного наследования.
     </details>

  #### 103. Что случится, если класс-наследник передать по значению в функцию, которая принимает базовый класс?

    - <details><summary>Ответ:</summary>

        - Если класс-наследник передается по значению в функцию, которая принимает базовый класс, то произойдет срезка
          объекта (object slicing). Это означает, что при передаче объекта производного класса в функцию, которая
          принимает объект базового класса по значению, будет создана копия объекта, но только часть, соответствующая
          базовому классу, будет скопирована. Все дополнительные данные и поведение, определенные в производном классе,
          будут утеряны.
        - Например, предположим, что у нас есть базовый класс `Shape` и производный класс `Circle`, который добавляет
          новое свойство `radius`. Если мы передадим объект класса `Circle` в функцию, которая принимает объект
          класса `Shape` по значению, то внутри функции будет доступна только часть объекта, соответствующая
          классу `Shape`. Свойство `radius` и любые другие данные или методы, определенные в классе `Circle`, будут
          недоступны.

        - ```c++
            class Shape {
            public:
                int x;
                int y;
            };
            
            class Circle : public Shape {
            public:
                int radius;
            };
            
            void printShape(Shape shape) {
                std::cout << "x: " << shape.x << ", y: " << shape.y << std::endl;
            }
            
            int main() {
                Circle circle;
                circle.x = 10;
                circle.y = 20;
                circle.radius = 5;
            
                printShape(circle); // Object slicing occurs
            }
            ```

        - В этом примере функция `printShape` принимает объект класса `Shape` по значению. Когда мы передаем объект
          класса `Circle` в эту функцию, происходит срезка объекта и внутри функции доступны только свойства `x` и `y`,
          определенные в классе `Shape`. Свойство `radius`, определенное в классе `Circle`, недоступно. Чтобы избежать
          срезки объекта, можно передавать объекты по ссылке или указателю. В этом случае в функции будет доступен
          полный объект производного класса.

        -   ```c++
            void printShape(const Shape& shape) {
                std::cout << "x: " << shape.x << ", y: " << shape.y << std::endl;
            }
            
            int main() {
                Circle circle;
                circle.x = 10;
                circle.y = 20;
                circle.radius = 5;
            
                printShape(circle); // No object slicing occurs
            }
            ```

        - В этом примере функция `printShape` принимает ссылку на объект класса `Shape`. Когда мы передаем объект
          класса `Circle` в эту функцию, срезка объекта не происходит и внутри функции доступен полный объект
          класса `Circle`.
    </details>

  #### 104. Что случится, если пронаследоваться от базового класса, который не имеет виртуального конструктора?

    - <details><summary>Ответ:</summary>

        - Если вы наследуетесь от базового класса, который не имеет виртуального деструктора, то это может привести к
          неправильному освобождению ресурсов при удалении объекта производного класса через указатель на базовый класс.
          Виртуальный деструктор гарантирует, что при удалении объекта через указатель на базовый класс будет вызван
          деструктор соответствующего производного класса. Это позволяет корректно освободить все ресурсы, которые были
          выделены в производном классе.
        - Если же базовый класс не имеет виртуального деструктора, то при удалении объекта через указатель на базовый
          класс будет вызван только деструктор базового класса. Это может привести к утечкам памяти и другим проблемам,
          если в производном классе были выделены какие-то ресурсы, которые требуют освобождения.
        - Например, предположим, что у нас есть базовый класс `Shape` и производный класс `Circle`, который выделяет
          память для хранения точек окружности:
        - ```c++
          class Shape {
          public:
              Shape() { std::cout << "Shape constructor" << std::endl; }
              ~Shape() { std::cout << "Shape destructor" << std::endl; }
          };
          class Circle : public Shape {
          public:
              Circle() : points(new int[10]) { std::cout << "Circle constructor" << std::endl; }
              ~Circle() { delete[] points; std::cout << "Circle destructor" << std::endl; }
          private:
              int* points;
          };
          int main() {
              Shape* shape = new Circle();
              delete shape;
          }
          ```

        - В этом примере базовый класс `Shape` не имеет виртуального деструктора. Когда мы создаем объект
          класса `Circle` и присваиваем его указателю на `Shape`, а затем удаляем этот объект через указатель на `Shape`
          , то вызывается только деструктор класса `Shape`. Деструктор класса `Circle` не вызывается, поэтому память,
          выделенная для массива `points`, не освобождается и происходит утечка памяти. Чтобы избежать этой проблемы,
          нужно объявить деструктор базового класса как виртуальный:
        - ```c++
          class Shape {
          public:
             Shape() { std::cout << "Shape constructor" << std::endl; }
             virtual ~Shape() { std::cout << "Shape destructor" << std::endl; }
          };
          class Circle : public Shape {
          public:
              Circle() : points(new int[10]) { std::cout << "Circle constructor" << std::endl; }
              ~Circle() { delete[] points; std::cout << "Circle destructor" << std::endl; }
          private:
              int* points;
          };
          int main() {
              Shape* shape = new Circle();
              delete shape;
          }
          ```

        - Теперь при удалении объекта через указатель на `Shape` вызывается деструктор соответствующего производного
          класса (`Circle`), который корректно освобождает выделенную память. Это предотвращает утечку памяти и другие
          проблемы.

    </details>

  #### 105. Что случится, если вызвать переопределенную virtual function из конструктора? Может ли конструктор быть виртуальным?

    - <details><summary>Ответ:</summary>

        - Если вы вызовете виртуальную функцию из конструктора, то будет вызвана версия этой функции, определенная в том
          же классе, что и конструктор. Это происходит потому, что во время выполнения конструктора объект еще не
          полностью создан и таблица виртуальных функций еще не настроена для использования версий функций из
          производных классов. Это может привести к непредсказуемому поведению, если виртуальная функция использует
          данные, которые еще не были инициализированы. Поэтому вызов виртуальных функций из конструктора является
          плохой практикой и следует избегать этого.
        - Например, предположим, что у нас есть базовый класс `Shape` с виртуальной функцией `print`, которая
          переопределена в производном классе `Circle`. Если мы вызовем функцию `print` из конструктора класса `Shape`,
          то будет вызвана версия этой функции, определенная в классе `Shape`, а не в классе `Circle`.

        -  ```c++
            class Shape {
            public:
                Shape() { print(); }
                virtual void print() { std::cout << "Shape" << std::endl; }
            };
            
            class Circle : public Shape {
            public:
                Circle() : radius(5) {}
                void print() override { std::cout << "Circle with radius " << radius << std::endl; }
            
            private:
                int radius;
            };
            
            int main() {
                Circle circle;
            }
           ```

        - В этом примере конструктор класса `Shape` вызывает виртуальную функцию `print`. Однако, поскольку вызов
          происходит до того, как объект `Circle` полностью создан, вызывается версия функции `print`, определенная в
          классе `Shape`, а не в классе `Circle`. В результате выводится строка "Shape", а не "Circle with radius 5".
        - Что касается второго вопроса, то нет, конструктор не может быть виртуальным. Виртуальные функции используются
          для реализации полиморфизма времени выполнения, когда тип объекта определяется динамически во время выполнения
          программы. Однако конструкторы используются для создания объектов и их тип должен быть известен статически во
          время компиляции. Поэтому нет смысла делать конструктор виртуальным.
    </details>

  #### 106. Может ли pure virtual function иметь имплементацию? Что случится, если вызвать pure virtual function из конструктора?

    - <details><summary>Ответ:</summary>

        - Да, чисто виртуальная функция (pure virtual function) может иметь реализацию в базовом классе. Чтобы
          определить реализацию для чисто виртуальной функции, нужно определить ее за пределами объявления класса, как
          обычную функцию. Однако, поскольку функция является чисто виртуальной, производные классы все равно должны
          предоставить свою реализацию этой функции.
        - Например, предположим, что у нас есть базовый класс `Shape` с чисто виртуальной функцией `print`. Мы можем
          определить реализацию этой функции в классе `Shape` следующим образом:

        -  ```c++
            class Shape {
            public:
                virtual void print() = 0;
            };
            
            void Shape::print() {
                std::cout << "Shape" << std::endl;
            }
            ```

        - В этом примере функция `print` объявлена как чисто виртуальная в классе `Shape`, но также имеет реализацию за
          пределами объявления класса. Эта реализация может быть вызвана из производных классов с помощью синтаксиса
          области видимости (`Shape::print()`).
        - Если вы вызовете чисто виртуальную функцию из конструктора или деструктора, то это приведет к неопределенному
          поведению. Во время выполнения конструктора или деструктора объект еще не полностью создан или уже начал
          уничтожаться, поэтому таблица виртуальных функций еще не настроена для использования версий функций из
          производных классов. Это может привести к ошибке времени выполнения или другим проблемам. Поэтому вызов чисто
          виртуальных функций из конструктора или деструктора является плохой практикой и следует избегать этого.
      </details>

  #### 107. Какие методы генерируются для класса по умолчанию? В каком случае такие методы не будут генерироваться? Как заставить компилятор добавить/удалить эти методы?

    - <details><summary>Ответ:</summary>

        - Для класса в C++ компилятор автоматически генерирует несколько специальных методов, если они не были явно
          определены программистом. Эти методы включают:
            1. **Конструктор по умолчанию**: конструктор, который не принимает аргументов и используется для создания
               объектов без явного указания начальных значений.
            2. **Конструктор копирования**: конструктор, который принимает объект того же класса по константной ссылке и
               используется для создания нового объекта как копии существующего.
            3. **Оператор присваивания**: оператор, который принимает объект того же класса по константной ссылке и
               используется для присваивания значения одного объекта другому.
            4. **Деструктор**: метод, который вызывается при уничтожении объекта и используется для освобождения
               ресурсов, выделенных для объекта.
            5. **Конструктор перемещения** (начиная с C++11): конструктор, который принимает rvalue-ссылку на объект
               того же класса и используется для создания нового объекта путем перемещения ресурсов из существующего
               объекта.
            6. **Оператор перемещения** (начиная с C++11): оператор, который принимает rvalue-ссылку на объект того же
               класса и используется для перемещения ресурсов из одного объекта в другой.

        - Эти методы генерируются компилятором только в том случае, если они могут быть сгенерированы без ошибок и не
          определены явно программистом. Например, если класс содержит константные или ссылочные члены данных или члены
          данных, которые не имеют конструктора по умолчанию, то компилятор не сможет сгенерировать конструктор по
          умолчанию. Аналогично, если класс содержит члены данных, которые не могут быть скопированы или перемещены, то
          компилятор не сможет сгенерировать соответствующие конструкторы копирования и перемещения или операторы
          присваивания.
        - Начиная с C++11 можно использовать ключевое слово `default` для явного указания компилятору сгенерировать
          специальный метод по умолчанию. Например, чтобы заставить компилятор сгенерировать конструктор по умолчанию
          для класса `MyClass`, можно написать:

        - ```c++
          class MyClass {
          public:
              MyClass() = default;
          };
          ```

        - Аналогично можно использовать ключевое слово `delete` для явного указания компилятору не генерировать
          специальный метод. Например, чтобы запретить копирование объектов класса `MyClass`, можно написать:

        - ```c++
          class MyClass {
          public:
              MyClass(const MyClass&) = delete;
              MyClass& operator=(const MyClass&) = delete;
          };
          ```

        - В этом случае попытка скопировать объект класса `MyClass` приведет к ошибке компиляции.
      </details>

  #### 108. Как запретить наследовать класс?

    - <details><summary>Ответ:</summary>

        - В C++11 и более поздних версиях можно запретить наследование класса, объявив его как `final`. Это означает,
          что класс не может быть использован в качестве базового для других классов. Попытка наследовать от класса,
          объявленного как `final`, приведет к ошибке компиляции.
        - Например, предположим, что у нас есть класс `Base`, который мы хотим запретить наследовать:

        - ```c++
            class Base final {
            public:
                void foo() {}
            };
            
            class Derived : public Base {}; // Error: cannot derive from 'final' base 'Base'
            ```

        - В этом примере класс `Base` объявлен как `final`, поэтому попытка создать класс `Derived`, который наследует
          от класса `Base`, приводит к ошибке компиляции.

        - В версиях C++ до C++11 не существует встроенного способа запретить наследование класса. Однако можно
          использовать различные трюки, чтобы сделать это невозможным или затруднительным. Например, можно сделать все
          конструкторы класса приватными и предоставить статический метод для создания объектов. Это не позволит
          производным классам вызывать конструкторы базового класса, что сделает наследование невозможным.

        -  ```c++
            class Base {
            public:
                static Base create() { return Base(); }
                void foo() {}
            
            private:
                Base() {}
            };
            
            class Derived : public Base {}; // Error: 'Base::Base()' is private
            ```
        - В этом примере все конструкторы класса `Base` являются приватными, поэтому попытка создать класс `Derived`,
          который
          наследует от класса `Base`, приводит к ошибке компиляции. Однако объекты класса `Base` все еще можно создавать
          с помощью
          статического метода `create`.
     </details>

  #### 109. Какой порядок конструирования и разрушения классов в иерархии? Порядок инициализации полей класса?

    - <details><summary>Ответ:</summary>

        - В иерархии наследования классов в C++ порядок конструирования объекта начинается с самого базового класса и
          продвигается вниз по иерархии к производным классам. Это означает, что конструкторы базовых классов вызываются
          до конструкторов производных классов.
        - Например, предположим, что у нас есть базовый класс `Base` и производный класс `Derived`, который наследует от
          класса `Base`. Если мы создадим объект класса `Derived`, то сначала будет вызван конструктор класса `Base`, а
          затем конструктор класса `Derived`.

        -  ```c++
            class Base {
            public:
                Base() { std::cout << "Base constructor" << std::endl; }
            };
            
            class Derived : public Base {
            public:
                Derived() { std::cout << "Derived constructor" << std::endl; }
            };
            
            int main() {
                Derived derived;
            }
            ```

        - В этом примере при создании объекта класса `Derived` сначала вызывается конструктор класса `Base`, который
          выводит строку "Base constructor", а затем вызывается конструктор класса `Derived`, который выводит строку "
          Derived constructor". Порядок разрушения объекта в иерархии наследования является обратным порядку
          конструирования. Это означает, что деструкторы производных классов вызываются до деструкторов базовых классов.

        - Например, используя тот же пример с классами `Base` и `Derived`, если мы удалим объект класса `Derived`, то
          сначала будет вызван деструктор класса `Derived`, а затем деструктор класса `Base`.

        - ```c++
            class Base {
            public:
                Base() { std::cout << "Base constructor" << std::endl; }
                ~Base() { std::cout << "Base destructor" << std::endl; }
            };
            
            class Derived : public Base {
            public:
                Derived() { std::cout << "Derived constructor" << std::endl; }
                ~Derived() { std::cout << "Derived destructor" << std::endl; }
            };
            
            int main() {
                Derived derived;
            }
            ```

        - В этом примере при удалении объекта класса `Derived` сначала вызывается деструктор класса `Derived`, который
          выводит строку "Derived destructor", а затем вызывается деструктор класса `Base`, который выводит строку "Base
          destructor". Что касается порядка инициализации полей класса, то поля инициализируются в том порядке, в
          котором они объявлены в классе. Это означает, что если у нас есть два поля `x` и `y`, объявленные в этом
          порядке, то поле `x` будет инициализировано до поля `y`.

        - Например:

        -  ```c++
            class MyClass {
            public:
                MyClass(int a, int b) : y(a), x(y + b) {}
                void print() { std::cout << "x: " << x << ", y: " << y << std::endl; }
            
            private:
                int x;
                int y;
            };
            
            int main() {
                MyClass myClass(1, 2);
                myClass.print();
            }
            ```
        - В этом примере поля `x` и `y` объявлены в этом порядке, поэтому поле `x` инициализируется до поля `y`. Однако
          в списке инициализации конструктора мы пытаемся инициализировать поле `y` до поля `x`. Это не имеет эффекта на
          порядок инициализации, поэтому поле `x` все равно инициализируется до поля `y`. В результате значение поля `x`
          не определено, так как оно зависит от значения поля `y`, которое еще не было инициализировано. Поэтому вывод
          программы может быть непредсказуемым.
    </details>

  #### 110. Какие есть способы инициализации полей класса?

    - <details><summary>Ответ:</summary>

        - В C++ существует несколько способов инициализации полей класса:

        1. **Список инициализации**: поля класса могут быть инициализированы в списке инициализации конструктора. Этот
           список находится после объявления конструктора и перед его телом и начинается с двоеточия. В списке
           инициализации указывается имя поля, за которым следует значение в круглых скобках.

        - ```c++
            class MyClass {
            public:
              MyClass(int a, int b) : x(a), y(b) {}
            private:
              int x;
              int y;
            };
          ```

        - В этом примере поля `x` и `y` инициализируются значениями `a` и `b` соответственно с помощью списка
          инициализации
          конструктора.

        2. **Присваивание в теле конструктора**: поля класса могут быть инициализированы путем присваивания значений в
           теле
           конструктора.

        - ```c++
          class MyClass {
          public:
              MyClass(int a, int b) {
                  x = a;
                  y = b;
              }
          private:
              int x;
              int y;
          };
          ```

        - В этом примере поля `x` и `y` инициализируются значениями `a` и `b` соответственно путем присваивания в теле
          конструктора.

        3. **Инициализация по умолчанию**: начиная с C++11, поля класса могут быть инициализированы значениями по
           умолчанию
           непосредственно в объявлении класса.

        - ```c++
          class MyClass {
          public:
              MyClass() {}
          private:
              int x = 0;
              int y = 0;
          };
          ```

        - В этом примере поля `x` и `y` инициализируются нулями по умолчанию при создании объекта класса `MyClass`.
        - Стоит отметить, что разные типы полей могут иметь разные требования к способу инициализации. Например, поля
          ссылочного
          типа или константные поля должны быть инициализированы в списке инициализации конструктора, так как они не
          могут быть
          изменены после создания объекта.
    </details>

  #### 111. Может ли деструктор быть виртуальным?

    - <details><summary>Ответ:</summary>

        - Да, деструктор может быть виртуальным. На самом деле, если у вас есть базовый класс с виртуальными функциями,
          то его деструктор тоже должен быть виртуальным. Это гарантирует, что при удалении объекта через указатель на
          базовый класс будет вызван деструктор соответствующего производного класса. Это позволяет корректно освободить
          все ресурсы, которые были выделены в производном классе. Если же базовый класс не имеет виртуального
          деструктора, то при удалении объекта через указатель на базовый класс будет вызван только деструктор базового
          класса. Это может привести к утечкам памяти и другим проблемам, если в производном классе были выделены
          какие-то ресурсы, которые требуют освобождения.
        - Например, предположим, что у нас есть базовый класс `Shape` и производный класс `Circle`, который выделяет
          память для хранения точек окружности:

        -  ```c++
            class Shape {
            public:
                virtual void draw() {}
            };
            
            class Circle : public Shape {
            public:
                Circle() : points(new int[10]) {}
                ~Circle() { delete[] points; }
                void draw() override {}
            
            private:
                int* points;
            };
            
            int main() {
                Shape* shape = new Circle();
                delete shape; // Only calls Shape's destructor
            }
            ```

        - В этом примере базовый класс `Shape` имеет виртуальную функцию `draw`, но его деструктор не является
          виртуальным. Когда мы создаем объект класса `Circle` и присваиваем его указателю на `Shape`, а затем удаляем
          этот объект через указатель на `Shape`, то вызывается только деструктор класса `Shape`. Деструктор
          класса `Circle` не вызывается, поэтому память, выделенная для массива `points`, не освобождается и происходит
          утечка памяти.

        - Чтобы избежать этой проблемы, нужно объявить деструктор базового класса как виртуальный:

        -  ```c++
            class Shape {
            public:
                virtual ~Shape() {}
                virtual void draw() {}
            };
            
            class Circle : public Shape {
            public:
                Circle() : points(new int[10]) {}
                ~Circle() { delete[] points; }
                void draw() override {}
            
            private:
                int* points;
            };
            
            int main() {
                Shape* shape = new Circle();
                delete shape; // Calls both Circle's and Shape's destructors
            }
            ```
        - Теперь при удалении объекта через указатель на `Shape` вызывается деструктор соответствующего производного
          класса (`Circle`), который корректно освобождает выделенную память. Это предотвращает утечку памяти и другие
          проблемы.

    </details>

  #### 112. Что делает ключевое слово virtual?

    - <details><summary>Ответ:</summary>

        - Ключевое слово `virtual` используется в C++ для создания виртуальных функций. Виртуальные функции позволяют
          реализовать полиморфизм времени выполнения, когда тип объекта определяется динамически во время выполнения
          программы. Виртуальная функция объявляется в базовом классе с помощью ключевого слова `virtual` и может быть
          переопределена в производных классах. Когда виртуальная функция вызывается через указатель или ссылку на
          базовый класс, то вызывается версия этой функции, соответствующая динамическому типу объекта, на который
          указывает указатель или ссылка.
        - Например, предположим, что у нас есть базовый класс `Shape` с виртуальной функцией `draw`, которая
          переопределена в производных классах `Circle` и `Rectangle`. Если мы создадим объекты классов `Circle`
          и `Rectangle` и присвоим их указателям на `Shape`, то при вызове функции `draw` через эти указатели будут
          вызваны версии этой функции, соответствующие динамическому типу объектов.

        -  ```c++
            class Shape {
            public:
                virtual void draw() { std::cout << "Drawing shape" << std::endl; }
            };
            
            class Circle : public Shape {
            public:
                void draw() override { std::cout << "Drawing circle" << std::endl; }
            };
            
            class Rectangle : public Shape {
            public:
                void draw() override { std::cout << "Drawing rectangle" << std::endl; }
            };
            
            int main() {
                Shape* shape1 = new Circle();
                Shape* shape2 = new Rectangle();
            
                shape1->draw(); // Calls Circle's draw
                shape2->draw(); // Calls Rectangle's draw
            
                delete shape1;
                delete shape2;
            }
            ```
        - В этом примере у нас есть два указателя на `Shape`, которые указывают на объекты классов `Circle`
          и `Rectangle`. Когда мы вызываем функцию `draw` через эти указатели, то вызываются версии этой функции,
          соответствующие динамическому типу объектов. То есть для указателя `shape1` вызывается версия функции `draw`,
          определенная в классе `Circle`, а для указателя `shape2` - версия функции `draw`, определенная в
          классе `Rectangle`.
        - Ключевое слово `virtual` также используется для создания виртуальных деструкторов. Виртуальный деструктор
          гарантирует, что при удалении объекта через указатель на базовый класс будет вызван деструктор
          соответствующего производного класса. Это позволяет корректно освободить все ресурсы, которые были выделены в
          производном классе.
     </details>

  #### 113. Для чего используют виртуальный деструктор?

    - <details><summary>Ответ:</summary>

        - Виртуальный деструктор используется в C++ для корректного освобождения ресурсов при удалении объекта через
          указатель на базовый класс. Если у вас есть базовый класс с виртуальными функциями, то его деструктор тоже
          должен быть виртуальным. Виртуальный деструктор гарантирует, что при удалении объекта через указатель на
          базовый класс будет вызван деструктор соответствующего производного класса. Это позволяет корректно освободить
          все ресурсы, которые были выделены в производном классе. Если же базовый класс не имеет виртуального
          деструктора, то при удалении объекта через указатель на базовый класс будет вызван только деструктор базового
          класса. Это может привести к утечкам памяти и другим проблемам, если в производном классе были выделены
          какие-то ресурсы, которые требуют освобождения.
        - Например, предположим, что у нас есть базовый класс `Shape` и производный класс `Circle`, который выделяет
          память для хранения точек окружности:

        -  ```c++
            class Shape {
            public:
                virtual void draw() {}
            };
            
            class Circle : public Shape {
            public:
                Circle() : points(new int[10]) {}
                ~Circle() { delete[] points; }
                void draw() override {}
            
            private:
                int* points;
            };
            
            int main() {
                Shape* shape = new Circle();
                delete shape; // Only calls Shape's destructor
            }
            ```

        - В этом примере базовый класс `Shape` имеет виртуальную функцию `draw`, но его деструктор не является
          виртуальным. Когда мы создаем объект класса `Circle` и присваиваем его указателю на `Shape`, а затем удаляем
          этот объект через указатель на `Shape`, то вызывается только деструктор класса `Shape`. Деструктор
          класса `Circle` не вызывается, поэтому память, выделенная для массива `points`, не освобождается и происходит
          утечка памяти.

          Чтобы избежать этой проблемы, нужно объявить деструктор базового класса как виртуальный:

        -   ```c++
            class Shape {
            public:
                virtual ~Shape() {}
                virtual void draw() {}
            };
            
            class Circle : public Shape {
            public:
                Circle() : points(new int[10]) {}
                ~Circle() { delete[] points; }
                void draw() override {}
            
            private:
                int* points;
            };
            
            int main() {
                Shape* shape = new Circle();
                delete shape; // Calls both Circle's and Shape's destructors
            }
            ```
        - Теперь при удалении объекта через указатель на `Shape` вызывается деструктор соответствующего производного
          класса (`Circle`), который корректно освобождает выделенную память. Это предотвращает утечку памяти и другие
          проблемы.
    </details>

  #### 114. Что такое глубокое копирование?

    - <details><summary>Ответ:</summary>

        - Глубокое копирование (deep copy) - это процесс создания нового объекта, который является полной копией
          исходного объекта, включая все его данные и ресурсы. Это означает, что все данные, на которые ссылается
          исходный объект, также копируются в новый объект.
        - Глубокое копирование отличается от поверхностного копирования (shallow copy), при котором создается новый
          объект, но данные, на которые ссылается исходный объект, не копируются. Вместо этого новый объект ссылается на
          те же данные, что и исходный объект.
        - Глубокое копирование обычно используется, когда объект содержит указатели или ссылки на другие данные или
          ресурсы, которые должны быть уникальными для каждого объекта. В этом случае простое поверхностное копирование
          может привести к проблемам, таким как утечки памяти или непреднамеренное изменение данных.
        - Например, предположим, что у нас есть класс `MyString`, который хранит строку в динамически выделенной памяти:

        -   ```c++
            class MyString {
            public:
                MyString(const char* str) : size(strlen(str)), data(new char[size + 1]) {
                    strcpy(data, str);
                }
                ~MyString() { delete[] data; }
            
                MyString(const MyString& other) : size(other.size), data(new char[size + 1]) {
                    strcpy(data, other.data);
                }
            
            private:
                size_t size;
                char* data;
            };
            ```

        - В этом примере класс `MyString` имеет конструктор копирования, который выполняет глубокое копирование данных.
          Когда мы создаем новый объект `MyString` как копию существующего объекта, то конструктор копирования выделяет
          новую память для хранения строки и копирует данные из исходного объекта в новый. Это гарантирует, что каждый
          объект `MyString` имеет свою собственную копию строки и изменение одного объекта не влияет на другие.
        - Глубокое копирование может быть более затратным по времени и ресурсам, чем поверхностное копирование, так как
          требует выделения новой памяти и копирования данных. Однако в некоторых случаях это необходимо для корректной
          работы программы.
    </details>

  #### 115. Что такое виртуальные функции и зачем они нужны?

    - <details><summary>Ответ:</summary>

        - Виртуальная функция - это функция-член, которую предполагается переопределить в производных классах. При
          ссылке на объект производного класса с помощью указателя или ссылки на базовый класс можно вызвать виртуальную
          функцию для этого объекта и выполнить версию функции производного класса. Виртуальные функции обеспечивают
          вызов соответствующей функции для объекта независимо от выражения, используемого для вызова функции ¹.
        - Вот пример кода на C++, который демонстрирует использование виртуальных функций:
        -  ```cpp
            #include <iostream>
            using namespace std;
            
            class Account {
            public:
                Account(double d) { _balance = d; }
                virtual ~Account() {}
                virtual double GetBalance() { return _balance; }
                virtual void PrintBalance() {
                    cerr << "Error. Balance not available for base type." << endl;
                }
            
            private:
                double _balance;
            };
            
            class CheckingAccount : public Account {
            public:
                CheckingAccount(double d) : Account(d) {}
                void PrintBalance() {
                    cout << "Checking account balance: " << GetBalance() << endl;
                }
            };
            
            class SavingsAccount : public Account {
            public:
                SavingsAccount(double d) : Account(d) {}
                void PrintBalance() { cout << "Savings account balance: " << GetBalance(); }
            };
            
            int main() {
                // Create objects of type CheckingAccount and SavingsAccount.
                CheckingAccount checking(100.00);
                SavingsAccount savings(1000.00);
            
                // Call PrintBalance using a pointer to Account.
                Account* pAccount = &checking;
                pAccount->PrintBalance();
            
                // Call PrintBalance using a pointer to Account.
                pAccount = &savings;
                pAccount->PrintBalance();
            }
            ```

        - В этом примере вызовы `PrintBalance` идентичны за исключением тех, на которые указывает объект `pAccount`.
          Поскольку функция `PrintBalance` виртуальная, вызывается версия функции, определенная для каждого объекта.
          Функция `PrintBalance` в производных классах `CheckingAccount` и `SavingsAccount` переопределяет функцию в
          базовом классе `Account` ¹.

    </details>

  #### 116. Как защитить объект от копирования?

    - <details><summary>Ответ:</summary>

        - Чтобы защитить объект от копирования, можно явно запретить конструктор копирования и оператор присваивания в
          классе. В C++11 и более поздних версиях это можно сделать с помощью ключевого слова `delete`:
        - ```cpp
          class NonCopyable {
          public:
              NonCopyable() = default;
              NonCopyable(const NonCopyable&) = delete;
              NonCopyable& operator=(const NonCopyable&) = delete;
          };
          ``` 
        - В этом примере конструктор копирования и оператор присваивания объявлены как `delete`, что означает, что они
          не могут быть использованы. Попытка скопировать объект этого класса приведет к ошибке компиляции ³.

   </details>

  #### 117. Что такое семантика перемещения?

    - <details><summary>Ответ:</summary>

        - Семантика перемещения (move semantics) - это собирательное название специализированных средств языка
          программирования C++, которые предназначены для осуществления перемещения данных во время инициализации и
          конструирования новых объектов, что позволяет сократить издержки на копирование.
        - Для практического осуществления семантики перемещения в синтаксис C++ введены rvalue ссылки, а также
          конструкторы перемещения и перемещающий оператор присваивания. Это позволяет оптимизировать вычислительные
          расходы там, где до этого применялась семантика передачи по значению. Оптимизация достигается отказом от
          копирования данных при создании временных объектов, у которых отсутствует необходимость сохранять их
          внутренние ресурсы для дальнейшего использования.
    </details>

---

- ### <span style="color:red">STL / Algorithms<span/>

  #### 118 Из чего состоит STL?

    - <details><summary>Ответ:</summary>

        - STL (Standard Template Library) - это библиотека шаблонов C++, которая предоставляет общие структуры данных и
          функции программирования, такие как списки, стеки, массивы и т. д. Она состоит из классов контейнеров,
          алгоритмов и итераторов. Это обобщенная библиотека, поэтому ее компоненты параметризованы.
        - STL состоит из четырех компонентов: алгоритмы, контейнеры, функции и итераторы. Контейнеры используются для
          хранения и управления данными. Алгоритмы используются для манипулирования данными, хранящимися в контейнерах.
          Итераторы предоставляют способ обхода элементов контейнера. Функции используются как аргументы функций для
          алгоритмов.
    </details>

  ### 119. Какие алгоритмы применяли с STL? В чем преимущество использования алгоритмов перед собственноручно написанными функциями?

    - <details><summary>Ответ:</summary>

        - STL (Standard Template Library) предоставляет множество алгоритмов, которые можно использовать с контейнерами
          STL. Некоторые из наиболее часто используемых алгоритмов включают `sort`, `find`, `count`, `accumulate`
          , `copy`, `reverse` и многие другие.
        - Преимущество использования алгоритмов STL перед собственноручно написанными функциями заключается в том, что
          они хорошо протестированы и оптимизированы, а также обеспечивают высокую степень переносимости и повторного
          использования кода. Алгоритмы STL написаны таким образом, чтобы работать с различными типами контейнеров и
          итераторов, что позволяет легко использовать их в различных ситуациях.
        - Кроме того, использование алгоритмов STL может улучшить читаемость кода и упростить его поддержку, поскольку
          они предоставляют стандартизированный интерфейс для выполнения распространенных операций над данными. Вместо
          написания собственных функций для каждой операции можно использовать соответствующий алгоритм STL, что
          упрощает код и делает его более понятным.
     </details>

  #### 120. Расскажите о контейнерах стандартной библиотеки vector, list, map, unordered_map.

    - <details><summary>Ответ:</summary>

        - `vector`, `list`, `map` и `unordered_map` являются контейнерами стандартной библиотеки C++. Они используются
          для хранения и управления данными в программе.
        - `vector` - это динамический массив, который может изменять свой размер во время выполнения программы. Он
          предоставляет быстрый доступ к элементам по индексу, но добавление или удаление элементов в начале или
          середине может быть медленным, так как требуется перемещение элементов.
        - `list` - это двусвязный список, который позволяет быстро добавлять и удалять элементы в любом месте списка.
          Однако доступ к элементам по индексу может быть медленным, так как требуется обход списка.
        - `map` - это ассоциативный контейнер, который хранит пары ключ-значение и обеспечивает быстрый поиск значения
          по ключу. Элементы в `map` хранятся в отсортированном порядке по ключу. Вставка, удаление и поиск элементов
          выполняются с логарифмической сложностью.
        - `unordered_map` - это также ассоциативный контейнер, который хранит пары ключ-значение и обеспечивает быстрый
          поиск значения по ключу. Однако в отличие от `map`, элементы в `unordered_map` не упорядочены. Вставка,
          удаление и поиск элементов выполняются с константной сложностью в среднем случае.
        - Каждый из этих контейнеров имеет свои преимущества и недостатки, и выбор подходящего контейнера зависит от
          требований к программе.

    </details>

  #### 121. Какие знаете типы итераторов? Чем они отличаются? В каких контейнерах используются?

    - <details><summary>Ответ:</summary>
      - <img src="Images/img_121_1.png">

        1. Итераторы - это объекты, которые предоставляют доступ к элементам контейнера и позволяют перемещаться между
           ними. В C++ существует несколько типов итераторов, которые отличаются по функциональности и используются в
           различных контейнерах.
        2. Итераторы ввода (Input iterators) - это итераторы, которые предоставляют доступ только для чтения к элементам
           контейнера. Они могут использоваться в алгоритмах, которые требуют только чтения данных, например, `find`
           или `count`. Итераторы ввода могут использоваться с контейнерами, которые поддерживают последовательный
           доступ к элементам, такими как `list` и `forward_list`.
        3. Итераторы вывода (Output iterators) - это итераторы, которые предоставляют доступ только для записи к
           элементам контейнера. Они могут использоваться в алгоритмах, которые изменяют данные, например, `copy`
           или `transform`. Итераторы вывода могут использоваться с контейнерами, которые поддерживают последовательный
           доступ к элементам.
        4. Прямые итераторы (Forward iterators) - это итераторы, которые предоставляют доступ для чтения и записи к
           элементам контейнера и позволяют перемещаться только вперед. Они могут использоваться с контейнерами, которые
           поддерживают последовательный доступ к элементам, такими как `list` и `forward_list`.
        5. Двунаправленные итераторы (Bidirectional iterators) - это итераторы, которые предоставляют доступ для чтения
           и записи к элементам контейнера и позволяют перемещаться вперед и назад. Они могут использоваться с
           контейнерами, которые поддерживают двунаправленный доступ к элементам, такими как `list`, `set`, `map`
           , `multiset` и `multimap`.
        6. Итераторы произвольного доступа (Random access iterators) - это итераторы, которые предоставляют доступ для
           чтения и записи к элементам контейнера и позволяют перемещаться вперед и назад на произвольное число шагов.
           Они могут использоваться с контейнерами, которые поддерживают произвольный доступ к элементам, такими
           как `vector`, `deque`, `array` и `string`.

        - Каждый тип итератора имеет свои преимущества и недостатки, и выбор подходящего типа зависит от требований к
          программе.

    </details>

  #### 122. Какая разница между std::set, std::map, std::unordered_multimap?

    - <details><summary>Ответ:</summary>

        1. `std::set`, `std::map` и `std::unordered_multimap` являются ассоциативными контейнерами стандартной
           библиотеки C++, которые используются для хранения и управления данными. Они имеют различия в хранении и
           организации данных, а также в производительности операций.
        2. `std::set` - это контейнер, который хранит уникальные элементы в отсортированном порядке. Он обеспечивает
           быстрый поиск, вставку и удаление элементов с логарифмической сложностью. `std::set` обычно реализуется с
           помощью красно-черного дерева.
        3. `std::map` - это контейнер, который хранит пары ключ-значение в отсортированном порядке по ключу. Он
           обеспечивает быстрый поиск, вставку и удаление элементов с логарифмической сложностью. Как и `std::set`
           , `std::map` обычно реализуется с помощью красно-черного дерева.
        4. `std::unordered_multimap` - это контейнер, который хранит пары ключ-значение в неупорядоченном порядке. Он
           обеспечивает быстрый поиск, вставку и удаление элементов с константной сложностью в среднем случае. В отличие
           от `std::set` и `std::map`, `std::unordered_multimap` реализуется с помощью хеш-таблицы. Он также позволяет
           хранить несколько элементов с одинаковым ключом.

        - Выбор между этими контейнерами зависит от требований к программе, таких как необходимость поддержки
          уникальности элементов, упорядоченности или быстродействия операций.
    </details>

  #### 123. Что такое идиома remove-erase?

    - <details><summary>Ответ:</summary>

        - Идиома remove-erase - это техника удаления элементов из контейнера в C++, которая использует комбинацию
          алгоритма `remove` или `remove_if` и метода `erase` контейнера. Эта идиома используется для удаления
          элементов, удовлетворяющих определенному условию, из контейнера, такого как `vector`, `deque` или `string`.
          Алгоритм `remove` перемещает все элементы, которые не удовлетворяют условию, в начало контейнера, а затем
          возвращает итератор на новый конец диапазона. Однако этот алгоритм не удаляет элементы из контейнера, а только
          перемещает их. Чтобы фактически удалить элементы из контейнера, необходимо использовать метод `erase`
          контейнера. Метод `erase` принимает диапазон элементов для удаления и удаляет их из контейнера.
        - Вот пример использования идиомы remove-erase для удаления всех элементов со значением 0 из вектора:
        - ```cpp
            std::vector<int> v = {1, 2, 0, 3, 0, 4};
            v.erase(std::remove(v.begin(), v.end(), 0), v.end());
          ```
        - В этом примере алгоритм `remove` перемещает все ненулевые элементы в начало вектора и возвращает итератор на
          новый конец диапазона. Затем метод `erase` удаляет все элементы от этого итератора до конца вектора.
      </details>

  #### 124. Как получить наименьшее значение типа?

    - <details><summary>Ответ:</summary>

        - Для получения наименьшего значения числового типа в C++ можно использовать
          функцию `std::numeric_limits::min()`, которая определена в заголовочном файле `<limits>`. Эта функция
          возвращает наименьшее значение, которое может быть представлено указанным типом.
        - Например, чтобы получить наименьшее значение типа `int`, можно использовать следующий код:
        -  ```cpp
            #include <limits>
            #include <iostream>
            
            int main() {
                int min_value = std::numeric_limits<int>::min();
                std::cout << "Minimum value for int: " << min_value << std::endl;
                return 0;
            }
           ```

        - В этом примере функция `std::numeric_limits<int>::min()` возвращает наименьшее значение, которое может быть
          представлено типом `int`, и это значение выводится на экран.
        - Также можно использовать эту функцию для других числовых типов, таких как `float`, `double`, `short` и т. д.,
          заменив `int` на соответствующий тип.
     </details>

  #### 125. Какая разница между std::map и std::hashmap?

    - <details><summary>Ответ:</summary>

        - В C++ нет контейнера с названием `std::hashmap`. Возможно, вы имели в виду `std::unordered_map`, который
          является ассоциативным контейнером, реализованным с помощью хеш-таблицы.
        - `std::map` и `std::unordered_map` являются ассоциативными контейнерами, которые хранят пары ключ-значение и
          обеспечивают быстрый поиск значения по ключу. Однако они имеют различия в организации данных и
          производительности операций.
        - `std::map` хранит элементы в отсортированном порядке по ключу. Он обеспечивает быстрый поиск, вставку и
          удаление элементов с логарифмической сложностью. `std::map` обычно реализуется с помощью красно-черного
          дерева.
        - `std::unordered_map` хранит элементы в неупорядоченном порядке. Он обеспечивает быстрый поиск, вставку и
          удаление элементов с константной сложностью в среднем случае. `std::unordered_map` реализуется с помощью
          хеш-таблицы.
        - Выбор между этими контейнерами зависит от требований к программе, таких как необходимость поддержки
          упорядоченности или быстродействия операций.
    </details>

  #### 126. Как подсчитать количество элементов в std::list?

    - <details><summary>Ответ:</summary>

        - Чтобы подсчитать количество элементов в контейнере `std::list`, можно использовать метод `size()`. Этот метод
          возвращает количество элементов, хранящихся в списке.

        - Вот пример использования метода `size()` для подсчета количества элементов в `std::list`:
        -  ```cpp
                #include <iostream>
                #include <list>
                
                int main() {
                    std::list<int> my_list = {1, 2, 3, 4, 5};
                    std::cout << "Number of elements in my_list: " << my_list.size() << std::endl;
                    return 0;
                }
           ```

        - В этом примере создается список `my_list`, содержащий пять элементов. Затем вызывается метод `size()`, который
          возвращает количество элементов в списке, и это значение выводится на экран.
        - Также можно использовать алгоритм `std::distance` для подсчета количества элементов между двумя итераторами.
          Однако для `std::list` этот алгоритм работает медленнее, чем метод `size()`, так как ему необходимо обойти все
          элементы списка.
    </details>

  #### 127. Что такое сложность алгоритма и от чего она зависит?

    - <details><summary>Ответ:</summary>

        - Сложность алгоритма - это мера того, насколько быстро время выполнения алгоритма растет с увеличением размера
          входных данных. Сложность обычно выражается как функция, которая описывает зависимость времени выполнения от
          размера входных данных.
        - Сложность алгоритма зависит от многих факторов, таких как:
            1. Количество операций, выполняемых алгоритмом.
            2. Структура данных, используемая алгоритмом.
            3. Размер входных данных.
            4. Характеристики входных данных (например, упорядоченность).

        - Существует несколько классов сложности, которые используются для описания алгоритмов. Например:
            1. Константная сложность (O(1)) - время выполнения алгоритма не зависит от размера входных данных.
            2. Логарифмическая сложность (O(log n)) - время выполнения алгоритма растет логарифмически с увеличением
               размера входных данных.
            3. Линейная сложность (O(n)) - время выполнения алгоритма растет линейно с увеличением размера входных
               данных.
            4. Квадратичная сложность (O(n^2)) - время выполнения алгоритма растет квадратично с увеличением размера
               входных данных.

        - Выбор алгоритма с подходящей сложностью может значительно повлиять на производительность программы, особенно
          при работе с большими объемами данных.
    </details>

  #### 128. В чем разница между vector и list и в каких случаях их лучше использовать?

    - <details><summary>Ответ:</summary>

        1. `std::vector` и `std::list` являются контейнерами последовательности в стандартной библиотеке C++, которые
           используются для хранения и управления данными. Они имеют различия в организации данных и производительности
           операций.
        2. `std::vector` - это динамический массив, который может изменять свой размер во время выполнения программы. Он
           предоставляет быстрый доступ к элементам по индексу, но добавление или удаление элементов в начале или
           середине может быть медленным, так как требуется перемещение элементов.
        3. `std::list` - это двусвязный список, который позволяет быстро добавлять и удалять элементы в любом месте
           списка. Однако доступ к элементам по индексу может быть медленным, так как требуется обход списка.

        - Выбор между `std::vector` и `std::list` зависит от требований к программе. Если важен быстрый доступ к
          элементам по индексу, то лучше использовать `std::vector`. Если же важно быстрое добавление или удаление
          элементов в начале или середине контейнера, то лучше использовать `std::list`.
        - В общем случае, если нет специфических требований к программе, то рекомендуется использовать `std::vector`,
          так как он обеспечивает хорошую производительность для большинства операций и эффективно использует память.

        <img src="Images/img_128_1.png">

    </details>

---

- ### <span style="color:red">Многопоточность<span/>

  #### 129. Что вам известно о многопоточности?

    - <details><summary>Ответ:</summary>

        - Многопоточность - это концепция, которая позволяет программе выполнять несколько задач одновременно. Это
          достигается путем создания нескольких потоков выполнения в рамках одного процесса, каждый из которых может
          выполнять отдельную задачу.
        - Многопоточность может улучшить производительность программы, особенно на многоядерных процессорах, где каждый
          поток может выполняться на отдельном ядре. Она также может улучшить отзывчивость программы, позволяя
          продолжать выполнение других задач во время длительных операций.
        - Однако многопоточность также может привести к сложностям в разработке и отладке программы. Например,
          необходимо обеспечить синхронизацию доступа к общим ресурсам, чтобы избежать состояний гонки и других проблем
          с параллелизмом.
        - В C++ существуют различные средства для работы с многопоточностью, такие как класс `std::thread` для создания
          и управления потоками, атомарные типы и операции для безопасного доступа к общим данным, а также примитивы
          синхронизации, такие как `std::mutex` и `std::condition_variable`, для координации работы нескольких потоков.
    </details>

  #### 130. Что общего и различного в процессах и потоках?

    - <details><summary>ответ:</summary>

        - Процессы и потоки являются основными концепциями, используемыми в операционных системах для управления
          выполнением программ.
        - Процесс - это экземпляр выполняющейся программы, который имеет свое собственное виртуальное адресное
          пространство и ресурсы, такие как файловые дескрипторы и переменные окружения. Каждый процесс имеет как
          минимум один поток выполнения, который выполняет инструкции программы.
        - Поток - это отдельная единица выполнения в рамках процесса. Каждый поток имеет свой собственный стек и
          регистры процессора, но разделяет общее адресное пространство и ресурсы с другими потоками в рамках одного
          процесса. Это позволяет потокам эффективно обмениваться данными и синхронизировать свою работу.
        - Основное различие между процессами и потоками заключается в том, что процессы являются изолированными друг от
          друга и имеют свои собственные ресурсы, в то время как потоки разделяют общее адресное пространство и ресурсы
          в рамках одного процесса. Это делает потоки более легковесными и быстрыми по сравнению с процессами, но также
          может привести к сложностям в управлении доступом к общим данным.
        - <img src="Images/img_130_1.png">
        - Разница между процессом и потоком:
        - <img src="Images/img_130_2.png">
        - <img src="Images/img_130_3.png">

    </details>

  #### 131. Как синхронизировать передачи информации между потоками?

    - <details><summary>Ответ:</summary>

        - Для синхронизации передачи информации между потоками в C++ можно использовать различные примитивы
          синхронизации, такие как мьютексы, условные переменные и семафоры. Мьютекс (mutex) - это примитив
          синхронизации, который используется для обеспечения взаимного исключения при доступе к общим данным. Он
          позволяет только одному потоку за раз входить в критическую секцию кода, где происходит доступ к общим данным.
          Другие потоки, которые пытаются войти в критическую секцию, будут заблокированы до тех пор, пока первый поток
          не выйдет из нее и не освободит мьютекс. Условная переменная (condition variable) - это примитив
          синхронизации, который используется для ожидания наступления определенного условия. Она позволяет одному или
          нескольким потокам ожидать наступления определенного условия, а другому потоку уведомлять их об этом. Условные
          переменные часто используются в сочетании с мьютексами для обеспечения атомарности проверки условия и ожидания
          его наступления.
        - Семафор (semaphore) - это примитив синхронизации, который используется для управления доступом к общим
          ресурсам. Он позволяет ограничить количество потоков, которые могут одновременно использовать общий ресурс.
        - Выбор подходящего примитива синхронизации зависит от требований к программе и способа передачи информации
          между потоками.
    </details>

  #### 132. Какая разница между мьютексом и семафором?

    - <details><summary>Ответ:</summary>

        - Мьютекс (mutex) и семафор (semaphore) являются примитивами синхронизации, которые используются для управления
          доступом к общим ресурсам в многопоточных программах. Они имеют различия в поведении и способах использования.
        - Мьютекс - это примитив синхронизации, который обеспечивает взаимное исключение при доступе к общим данным. Он
          позволяет только одному потоку за раз входить в критическую секцию кода, где происходит доступ к общим данным.
          Другие потоки, которые пытаются войти в критическую секцию, будут заблокированы до тех пор, пока первый поток
          не выйдет из нее и не освободит мьютекс.
        - Семафор - это примитив синхронизации, который используется для управления доступом к общим ресурсам. Он
          позволяет ограничить количество потоков, которые могут одновременно использовать общий ресурс. Семафор имеет
          счетчик, который указывает, сколько потоков может одновременно использовать ресурс. Когда поток хочет
          использовать ресурс, он уменьшает значение счетчика на единицу. Если счетчик равен нулю, то поток блокируется
          до тех пор, пока другой поток не освободит ресурс и не увеличит значение счетчика.
        - Основное различие между мьютексом и семафором заключается в том, что мьютекс позволяет только одному потоку за
          раз использовать общий ресурс, в то время как семафор может позволить нескольким потокам одновременно
          использовать ресурс. Выбор между мьютексом и семафором зависит от требований к программе и способа управления
          доступом к общим ресурсам.

    </details>

  #### 133. Что такое deadlock?

    - <details><summary>Ответ:</summary>

        - Deadlock - это ситуация в многопоточной программе, когда два или более потоков заблокированы навсегда, ожидая
          друг друга. Это происходит, когда несколько потоков конкурируют за доступ к общим ресурсам и блокируют друг
          друга, пытаясь получить их.
        - Например, представьте ситуацию, когда два потока, A и B, конкурируют за доступ к двум общим ресурсам, R1 и R2.
          Поток A захватывает ресурс R1 и ожидает освобождения ресурса R2. В то же время поток B захватывает ресурс R2 и
          ожидает освобождения ресурса R1. В этом случае оба потока заблокированы навсегда, так как каждый из них
          ожидает освобождения ресурса, который захвачен другим потоком.
        - Deadlock может привести к серьезным проблемам в работе программы, так как заблокированные потоки не могут
          продолжить свою работу. Чтобы предотвратить deadlock, необходимо тщательно проектировать алгоритмы
          синхронизации и управления доступом к общим ресурсам.
    </details>

  #### 134. Является ли С++ thread-safe?

    - <details><summary>Ответ:</summary>

        - C++ как язык программирования предоставляет средства для создания и управления потоками, а также примитивы
          синхронизации для обеспечения безопасного доступа к общим данным в многопоточных программах. Однако сам по
          себе C++ не является thread-safe.
        - Thread-safety означает, что код может безопасно выполняться одновременно в нескольких потоках без риска
          повреждения данных или непредсказуемого поведения. Достижение thread-safety зависит от того, как код написан и
          как он использует общие данные и ресурсы.
        - Некоторые части стандартной библиотеки C++ являются thread-safe, например, атомарные типы и операции, а также
          некоторые функции для работы с временем. Однако большинство компонентов стандартной библиотеки не являются
          thread-safe и требуют синхронизации при использовании в многопоточных программах.
        - В конечном итоге ответственность за обеспечение thread-safety лежит на разработчике программы. Это требует
          тщательного проектирования алгоритмов и использования примитивов синхронизации для обеспечения безопасного
          доступа к общим данным.

   </details>

  #### 135. Что такое race-condition?

    - <details><summary>Ответ:</summary>

        - Race condition - это ситуация в многопоточной программе, когда поведение программы зависит от того, в каком
          порядке выполняются операции в разных потоках. Это может привести к непредсказуемому и некорректному поведению
          программы, если операции, которые должны выполняться в определенном порядке, выполняются одновременно или в
          неправильном порядке.
        - Race condition часто возникает при доступе к общим данным без должной синхронизации. Например, представьте
          ситуацию, когда два потока одновременно увеличивают значение общей переменной. Если оба потока прочитают
          значение переменной, увеличат его на единицу и запишут обратно, то в итоге значение переменной увеличится
          только на единицу, а не на два, как ожидалось.
        - Чтобы предотвратить race condition, необходимо использовать примитивы синхронизации, такие как мьютексы или
          атомарные операции, для обеспечения корректного порядка выполнения операций и безопасного доступа к общим
          данным.
    </details>

  #### 136. Как избежать состояния гонки?

    - <details><summary>Ответ:</summary>

        - Состояние гонки (race condition) - это ситуация в многопоточной программе, когда поведение программы зависит
          от того, в каком порядке выполняются операции в разных потоках. Чтобы избежать состояния гонки, необходимо
          обеспечить корректный порядок выполнения операций и безопасный доступ к общим данным.
        - Вот несколько способов избежать состояния гонки в многопоточных программах:
            1. Использовать примитивы синхронизации, такие как мьютексы, условные переменные или семафоры, для
               обеспечения взаимного исключения при доступе к общим данным и координации работы нескольких потоков.
            2. Использовать атомарные типы и операции для обеспечения атомарного доступа к общим данным без
               необходимости блокировки.
            3. Разрабатывать алгоритмы таким образом, чтобы минимизировать доступ к общим данным и уменьшить вероятность
               возникновения состояния гонки.
            4. Использовать thread-local storage для хранения данных, которые используются только одним потоком, чтобы
               избежать необходимости синхронизации доступа к ним.

        - Использование этих и других методов может помочь избежать состояния гонки и обеспечить корректную работу
          многопоточных программ.
      </details>

  #### 137. Что такое атомарная операция?

    - <details><summary>Ответ:</summary>

        - Атомарная операция - это операция, которая либо выполняется целиком, либо не выполняется вовсе. Она не может
          быть частично выполнена и частично не
          выполнена[¹](https://ru.wikipedia.org/wiki/%D0%90%D1%82%D0%BE%D0%BC%D0%B0%D1%80%D0%BD%D0%B0%D1%8F_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F)
          . Атомарные операции используются в многопроцессорных
          компьютерах и в многозадачных операционных системах для обеспечения доступа нескольких процессов и/или
          нескольких потоков одного процесса к разделяемым между ними ресурсам. Атомарность операций может
          обеспечиваться аппаратно (аппаратурой) и программно (программным кодом).

    </details>

  #### 138. Как работать с std::mutex?

    - <details><summary>Ответ:</summary>

        - `std::mutex` - это класс, который представляет
          мьютекс ([взаимное исключение](https://en.cppreference.com/w/cpp/thread/mutex)). Он используется для защиты
          общих
          данных от одновременного доступа нескольких потоков. Обычно `std::mutex` не используется напрямую, а
          управляется с помощью `std::unique_lock`, `std::lock_guard` или `std::scoped_lock` (начиная с C++17), которые
          обеспечивают более безопасное управление блокировками в случае исключений³.
        - Чтобы использовать `std::mutex`, вы должны включить заголовочный файл `<mutex>` и создать объект `std::mutex`.
          Затем вы можете использовать методы `.lock()` и `.unlock()` для захвата и освобождения мьютекса
          соответственно. Например:
        -   ```cpp
            #include <mutex>
            std::mutex my_mutex;
            // ...
            my_mutex.lock();
            // критическая секция кода
            my_mutex.unlock();
            ```
        - Однако рекомендуется использовать управление блокировками с помощью `std::unique_lock`, `std::lock_guard`
          или `std::scoped_lock`, чтобы обеспечить автоматическое освобождение мьютекса в случае
          исключения[³](https://en.cppreference.com/w/cpp/thread/mutex).

    </details>

---

- ### Networking

  #### 139. Что такое сокет?

    - <details><summary>Ответ:</summary>

        - Сокет - это программный интерфейс для обеспечения информационного обмена между
          процессами[¹](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BA%D0%B5%D1%82_%28%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D1%8B%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%29)
          . Сокет представляет
          собой абстрактный объект, который является конечной точкой соединения. Следует различать клиентские и
          серверные сокеты. Клиентские сокеты можно грубо сравнить с конечными аппаратами телефонной сети, а серверные
            - с коммутаторами. Сокеты используются для обмена данными между процессами, которые могут исполняться как на
              одной ЭВМ, так и на различных ЭВМ, связанных между собой только сетью.

     </details>

  #### 140. Какие операции можно делать с сокетом?

    - <details><summary>Ответ:</summary>

      -- С сокетом можно выполнять различные операции, такие как ввод-вывод данных, изменение состояния, опрос и
      [другие(https://habr.com/ru/companies/skillfactory/articles/691296/). Например, можно создать сокет и привязать
      его к определенному порту, чтобы прослушивать входящие
      соединения. Также можно использовать сокет для подключения к удаленному серверу и обмена данными с ним.
      Операции с сокетами могут быть различными в зависимости от используемого протокола (например, TCP или UDP) и
      операционной системы.
    </details>

  #### 141. Какая информация нужна, чтобы создать сокет?

    - <details><summary>Ответ:</summary>

        - Чтобы создать сокет в C++, вам необходимо знать тип сокета, который вы хотите создать, а также домен и
          протокол, которые будут использоваться. Домен определяет семейство протоколов, которые будут использоваться
          для обмена данными. Например, `AF_INET` для IPv4 и `AF_INET6` для IPv6. Тип сокета определяет способ передачи
          данных. Например, `SOCK_STREAM` для потоковой передачи данных (TCP) и `SOCK_DGRAM` для датаграммной передачи
          данных (UDP). Протокол определяет конкретный протокол, который будет использоваться в рамках выбранного домена
          и типа сокета.
        - Вот пример создания сокета в C++:
        -  ```cpp
            #include <sys/socket.h>
            // ...
            int sockfd = socket(AF_INET, SOCK_STREAM, 0);
            ```

        - В этом примере мы создаем сокет для потоковой передачи данных по протоколу IPv4.

     </details>

  #### 142. Какие бывают модели сетей?

    - <details><summary>Ответ:</summary>

        - Существует несколько известных сетевых моделей. Одна из наиболее известных - это **модель OSI** (Open Systems
          Interconnection model), которая является эталонной моделью и описывает семь уровней взаимодействия систем.
          Другая популярная модель - это **модель DOD** (Модель TCP/IP), которая используется для работы в Интернете.
          Также существуют другие сетевые модели, такие как **модель SPX/IPX** (семейство протоколов для ЛВС) и **модель
          AppleTalk** (протоколы для работы сетей с оборудованием
          Apple)[¹](https://bing.com/search?q=%d0%bc%d0%be%d0%b4%d0%b5%d0%bb%d0%b8+%d1%81%d0%b5%d1%82%d0%b5%d0%b9).

      </details>

  #### 143. Расскажите об уровнях модели OSI.

    - <details><summary>Ответ:</summary>

        - <img src="Images/img_143_1.png">

        - Модель OSI (Open Systems Interconnection) - это сетевая модель, которая состоит из семи уровней. Каждый
          уровень выполняет определенные функции и отвечает за определенные аспекты передачи данных. Вот краткое
          описание каждого уровня:
            1. **Физический уровень (Physical layer)** - отвечает за передачу битов данных по физическому каналу связи.
               На этом уровне определяются характеристики физического соединения, такие как тип кабеля, разъемы и
               сигналы.
            2. **Канальный уровень (Data Link layer)** - отвечает за передачу кадров данных между соседними узлами сети.
               На этом уровне обеспечивается корректность передачи данных и контроль ошибок.
            3. **Сетевой уровень (Network layer)** - отвечает за маршрутизацию пакетов данных в сети. На этом уровне
               определяется путь передачи данных от источника к получателю.
            4. **Транспортный уровень (Transport layer)** - отвечает за доставку данных от отправителя к получателю. На
               этом уровне обеспечивается надежность передачи данных и контроль потока данных.
            5. **Сеансовый уровень (Session layer)** - отвечает за установление, поддержание и завершение сеансов связи
               между приложениями.
            6. **Уровень представления (Presentation layer)** - отвечает за представление данных в понятном для
               приложений виде. На этом уровне происходит преобразование данных в формат, который может быть обработан
               приложениями.
            7. **Прикладной уровень (Application layer)** - отвечает за взаимодействие приложений с сетью. На этом
               уровне определяются протоколы прикладного уровня, такие как HTTP, FTP и SMTP.
        - Эти уровни работают вместе, чтобы обеспечить надежную передачу данных между компьютерами в сети.

   </details>

  #### 144. Расскажите об уровнях модели TCP/IP.

    - <details><summary>Ответ:</summary>

        - Модель TCP/IP - это сетевая модель, которая состоит из четырех уровней¹. Вот краткое описание каждого уровня:
            1. **Прикладной уровень (Application layer)** - отвечает за взаимодействие приложений с сетью. На этом
               уровне определяются протоколы прикладного уровня, такие как HTTP, FTP и SMTP.
            2. **Транспортный уровень (Transport layer)** - отвечает за доставку данных от отправителя к получателю. На
               этом уровне обеспечивается надежность передачи данных и контроль потока данных.
            3. **Межсетевой уровень (Internet layer)** - отвечает за маршрутизацию пакетов данных в сети. На этом уровне
               определяется путь передачи данных от источника к получателю.
            4. **Канальный уровень (Network Access layer)** - отвечает за передачу кадров данных между соседними узлами
               сети. На этом уровне обеспечивается корректность передачи данных и контроль ошибок.
        - Эти уровни работают вместе, чтобы обеспечить надежную передачу данных между компьютерами в сети.

            - <img src="Images/img_144_1.png">
            - <img src="Images/img_144_2.png">
            - <img src="Images/img_144_3.png">

    </details>

  #### 145. Что такое IP-адрес?

    - <details><summary>Ответ:</summary>

        - IP-адрес (Internet Protocol address) - это уникальный числовой идентификатор, который присваивается каждому
          устройству, подключенному к сети Интернет. IP-адрес используется для идентификации устройства в сети и для
          маршрутизации данных между устройствами.
        - Существует две версии IP-адресов: IPv4 и IPv6. IPv4-адрес состоит из 32 битов и записывается в виде четырех
          десятичных чисел, разделенных точками, например, 192.168.1.1. IPv6-адрес состоит из 128 битов и записывается в
          виде восьми групп шестнадцатеричных чисел, разделенных двоеточиями, например, 2001:0db8:85a3:0000:0000:8a2e:
          0370:7334.
    </details>

  #### 146. Для чего используется маска подсети?

    - <details><summary>Ответ:</summary>

        - Маска подсети используется для определения того, какие IP-адреса принадлежат к одной и той же подсети. Маска
          подсети представляет собой последовательность битов, которая определяет, какие биты в IP-адресе относятся к
          адресу сети, а какие - к адресу узла в этой сети.
        - Например, если маска подсети равна 255.255.255.0, это означает, что первые 24 бита IP-адреса относятся к
          адресу сети, а последние 8 бит - к адресу узла. Таким образом, все IP-адреса, у которых первые 24 бита
          совпадают, принадлежат к одной и той же подсети.
        - Маска подсети используется маршрутизаторами для определения пути передачи данных между устройствами в сети.
          Маршрутизатор сравнивает IP-адрес назначения с маской подсети, чтобы определить, принадлежит ли адрес
          назначения к той же подсети, что и отправитель. Если это так, то данные передаются напрямую между
          устройствами. Если нет, то данные передаются через другие маршрутизаторы до тех пор, пока не достигнут нужной
          подсети.
        - <img src="Images/img_146_1.png">
    </details>

  #### 147. Какая разница между IPv4 и IPv6?

    - <details><summary>Ответ:</summary>

        - IPv4 и IPv6 - это две версии протокола IP (Internet Protocol), который используется для идентификации
          устройств в сети Интернет и для маршрутизации данных между ними. Основное отличие между IPv4 и IPv6
          заключается в размере адресного пространства.

        - IPv4-адрес состоит из 32 битов, что означает, что теоретически может быть около 4,3 миллиарда уникальных
          адресов. Однако из-за роста числа устройств, подключенных к Интернету, адресное пространство IPv4 стало
          нехватать.

        - IPv6 был разработан как решение этой проблемы. IPv6-адрес состоит из 128 битов, что означает, что теоретически
          может быть около 340 сексдециллионов (3.4 x 10^38) уникальных адресов. Это огромное количество адресов,
          которое должно хватить на долгое время.

        - Кроме размера адресного пространства, между IPv4 и IPv6 есть и другие отличия, такие как формат записи адресов
          и дополнительные функции безопасности в IPv6.

      ##### Разница между IPv4 и IPv6:
        - <img src="Images/img_147_1.png">
        - <img src="Images/img_147_2.png">
        - <img src="Images/img_147_3.png">

    </details>

  #### 148. Сколько памяти необходимо для хранения IPv4?

    - <details><summary>Ответ:</summary>

        - IPv4-адрес состоит из 32 битов, поэтому для его хранения необходимо 4 байта памяти (1 байт = 8 бит). Однако в
          зависимости от того, как адрес хранится и используется в программе, может потребоваться дополнительная память
          для хранения дополнительной информации, такой как маска подсети или порт.
     </details>

  #### 149. Для чего нужен порт?

    - <details><summary>Ответ:</summary>

        - Порт - это числовой идентификатор, который используется в сетевых протоколах транспортного уровня (например,
          TCP и UDP) для идентификации конкретного приложения или процесса на устройстве. Когда данные отправляются по
          сети, они помечаются номером порта отправителя и номером порта получателя. Это позволяет операционной системе
          на устройстве получателя определить, какому приложению или процессу следует передать данные.
        - Например, когда вы открываете веб-страницу в браузере, ваш компьютер отправляет запрос на сервер через порт
          80 (стандартный порт для протокола HTTP). Сервер получает запрос и отправляет ответ обратно на ваш компьютер
          через тот же порт 80. Операционная система на вашем компьютере видит, что данные пришли на порт 80, и передает
          их вашему браузеру для отображения веб-страницы.
        - Порты позволяют одновременно работать нескольким приложениям с сетью на одном и том же устройстве. Каждое
          приложение может использовать свой уникальный номер порта, чтобы избежать конфликтов с другими приложениями.
     </details>

  #### 150. Сколько максимально может быть портов?

    - <details><summary>Ответ:</summary>

        - Номер порта представляет собой 16-битное целое число, поэтому теоретически может быть максимум 65535 портов (
          от 0 до 65535 включительно). Однако некоторые из этих портов зарезервированы для определенных целей и не могут
          использоваться произвольно.

        - Например, порты с номерами от 0 до 1023 являются зарезервированными и используются для хорошо известных служб,
          таких как HTTP (порт 80), FTP (порт 21) и SSH (порт 22). Порты с номерами от 1024 до 49151 являются
          зарегистрированными и могут использоваться для определенных приложений, но не зарезервированы. Порты с
          номерами от 49152 до 65535 являются динамическими или частными и могут использоваться произвольно.
        </details>

  #### 151. Какая разница между TCP и UDP?

    - <details><summary>Ответ:</summary>

        - TCP (Transmission Control Protocol) и UDP (User Datagram Protocol) - это два протокола транспортного уровня,
          которые используются для передачи данных по сети Интернет. Они имеют ряд отличий в том, как они обрабатывают и
          передают данные.

        - TCP - это протокол с установлением соединения, который обеспечивает надежную передачу данных. Перед началом
          передачи данных между двумя устройствами TCP устанавливает соединение и согласовывает параметры передачи
          данных. В процессе передачи данных TCP обеспечивает контроль ошибок и повторную передачу потерянных или
          поврежденных пакетов. Это обеспечивает надежную доставку данных без потерь и повреждений.

        - UDP - это протокол без установления соединения, который не обеспечивает надежную передачу данных. UDP просто
          отправляет пакеты данных без предварительного установления соединения и без контроля ошибок. Это означает, что
          пакеты могут быть потеряны или повреждены в процессе передачи, и UDP не будет повторно отправлять их.

        - Выбор между TCP и UDP зависит от требований к приложению. TCP лучше подходит для приложений, которым требуется
          надежная передача данных, таких как веб-браузеры или электронная почта. UDP лучше подходит для приложений,
          которым важнее скорость передачи данных, чем надежность, например, для потокового видео или онлайн-игр.
        - <img src="Images/img_151_1.png">
        - <img src="Images/img_151_2.png">
        - <img src="Images/img_151_3.png">

    </details>

  #### 152. Для чего такой ненадежный UDP-протокол?

    - <details><summary>Ответ:</summary>

        - UDP (User Datagram Protocol) - это протокол транспортного уровня, который обеспечивает быструю передачу данных
          без установления соединения и без контроля ошибок. Хотя это может привести к потере или повреждению пакетов
          данных, в некоторых случаях использование UDP может быть предпочтительнее, чем использование более надежного,
          но более медленного протокола TCP (Transmission Control Protocol).
        - Один из примеров использования UDP - это потоковое видео или аудио. В этих приложениях важнее обеспечить
          низкую задержку и высокую скорость передачи данных, чем гарантировать доставку каждого пакета. Потеря
          нескольких пакетов может привести к небольшим помехам в видео или аудио, но это обычно менее заметно, чем
          задержка, которая может возникнуть при использовании TCP.
        - Другой пример использования UDP - это онлайн-игры. В этих приложениях важно обеспечить быструю передачу данных
          между игроками, чтобы минимизировать задержку. Потеря нескольких пакетов может привести к небольшим помехам в
          игре, но это обычно менее критично, чем задержка, которая может возникнуть при использовании TCP.
        - В общем, UDP используется в приложениях, где скорость и низкая задержка важнее, чем надежность передачи
          данных.
       </details>

---

- ### OS/Linux

  #### 153. Что такое менеджер пакетов?

    - <details><summary>Ответ:</summary>

        - Менеджер пакетов - это программа, которая используется для управления установкой, обновлением и удалением
          программного обеспечения на компьютере. Менеджер пакетов работает с репозиториями, которые содержат коллекции
          пакетов программного обеспечения. Каждый пакет содержит информацию о программе, включая ее зависимости от
          других пакетов.
        - Менеджер пакетов позволяет пользователю легко устанавливать, обновлять и удалять программы, не заботясь о том,
          какие зависимости необходимо установить или удалить. Менеджер пакетов автоматически обрабатывает все
          зависимости и обеспечивает, чтобы все необходимые пакеты были установлены в правильном порядке.
        - Менеджеры пакетов широко используются в Linux и других Unix-подобных операционных системах. Некоторые примеры
          менеджеров пакетов включают в себя `apt` (для Debian и Ubuntu), `yum` (для Fedora и Red Hat) и `pacman` (для
          Arch Linux).

    </details>

  #### 154. Какие бывают менеджеры пакетов?

    - <details><summary>Ответ:</summary>

        - В Linux есть несколько пакетных менеджеров. Некоторые из них включают **YUM**, **APT**, **Pacman**, **
          Zypp/Zypper**[¹](https://www.pcwdld.com/best-linux-package-managers/). Пакетный менеджер - это инструмент,
          который позволяет пользователям устанавливать, удалять,
          обновлять, настраивать и управлять программными пакетами в операционной
          системе[⁴](https://ubuntu.com/server/docs/package-management). Что еще вы хотели бы узнать?

      </details>

  #### 155. Какие бывают дистрибутивы Linux?

    - <details><summary>Ответ:</summary>

        - Существует [множество](https://en.wikipedia.org/wiki/List_of_Linux_distributions) дистрибутивов Linux, каждый
          со своими особенностями и преимуществами. Некоторые из самых
          популярных дистрибутивов включают **Ubuntu**, **Debian**, **Fedora**, **OpenSUSE**, **Linux Mint**, **Arch
          Linux**, **Slackware Linux** и **Gentoo Linux**¹. Вы можете изучить различные дистрибутивы Linux и найти тот,
          который соответствует вашим потребностям⁴. Что еще вы хотели бы узнать?

     </details>

  #### 156. Что такое PID?

    - <details><summary>Ответ:</summary>

        - PID - это уникальный идентификационный номер, который используется для идентификации конкретного процесса в
          Linux. Это сокращение от Process IDentifier[³](https://linuxhandbook.com/find-process-id/). Каждый запущенный
          приложение, утилита и демон имеют свой
          PID[¹](https://www.cyberciti.biz/faq/how-to-end-task-with-pid-in-linux/).
          Вы можете использовать команду `pidof` или `pgrep`, чтобы найти PID процесса. Что еще вы хотели бы узнать?

    </details>

  #### 157. Для чего используют файловые дескрипторы?

    - <details><summary>Ответ:</summary>

        - Файловые дескрипторы - это уникальные целочисленные значения, которые служат идентификаторами для открытых
          файлов или каналов связи в
          Linux[⁴](https://stackoverflow.com/questions/5256599/what-are-file-descriptors-explained-in-simple-terms). Они
          используются для представления и управления потоками ввода-вывода между
          процессами и файлами, сокетами, каналами и другими источниками или назначениями данных. Каждый процесс имеет
          свой собственный набор открытых файлов[³](https://en.wikipedia.org/wiki/File_descriptor). Что еще вы хотели бы
          узнать?

    </details>

  #### 158. Расскажите о стандартных файловых дескрипторах процесса.

    - <details><summary>Ответ:</summary>

        - Большинство процессов (за исключением некоторых демонов) имеют три стандартных файловых дескриптора: **stdin**
          , **stdout** и **stderr**[¹](
          LinuxForDevices. https://www.linuxfordevices.com/tutorials/linux/file-descriptors). Эти файловые дескрипторы
          соответствуют трем стандартным потокам: **stdin** (
          стандартный ввод) обозначается файловым дескриптором 0, **stdout** (стандартный вывод) обозначается файловым
          дескриптором 1, а **stderr** (стандартная ошибка) обозначается файловым дескриптором
          2[³](https://www.howtogeek.com/435903/what-are-stdin-stdout-and-stderr-on-linux/). Что еще вы хотели бы
          узнать?
     </details>

  #### 159. Что такое Pipe?

    - <details><summary>Ответ:</summary>

        - Pipe - это однонаправленный канал данных, который может использоваться для межпроцессного обмена данными в
          Linux[²](https://www.howtogeek.com/438882/how-to-use-pipes-on-linux/). Он позволяет передавать вывод одной
          команды в качестве входных данных для другой команды. Это
          позволяет создавать цепочки команд, которые могут обрабатывать данные
          последовательно[¹](https://www.man7.org/linux/man-pages/man2/pipe.2.html). Что еще вы хотели бы
          узнать?

         </details>

  #### 160. Что такое Named Pipe?

    - <details><summary>Ответ:</summary>

        - Named Pipe (FIFO) - это специальный файл, который похож на обычный pipe, но имеет имя в файловой системе.
          Несколько процессов могут получить доступ к этому специальному файлу для чтения и записи, как к обычному
          файлу. Таким образом, имя используется только как точка отсчета для процессов, которым необходимо использовать
          имя в файловой системе[¹](https://www.baeldung.com/linux/anonymous-named-pipes). Что еще вы хотели бы узнать?
    </details>

  #### 161. Что такое UID?

    - <details><summary>Ответ:</summary>

        - UID - это уникальный идентификационный номер, который присваивается каждому пользователю Linux. Это
          представление пользователя в ядре Linux. UID используется для идентификации пользователя в системе и для
          определения того, к каким системным ресурсам пользователь имеет
          доступ[¹](https://linuxhandbook.com/uid-linux/). Что еще вы хотели бы узнать?

     </details>

  #### 162. Расскажите о командах bash.

    - <details><summary>Ответ:</summary>

        - Команды Bash выполняют широкий спектр задач, таких как создание, перемещение, переименование и удаление файлов
          и каталогов, сравнение и объединение файлов, редактирование и манипулирование текстом в файлах, сжатие и
          распаковка файлов, планирование задач для автоматического выполнения, сетевое взаимодействие и удаленный
          доступ[¹](https://www.educative.io/blog/bash-shell-command-cheat-sheet). Что еще вы хотели бы узнать?

    </details>

---

- ### SCM / CI / CD

  #### 163. Какие есть виды SCM?

    - <details><summary>Ответ:</summary>

        - SCM - это сокращение от Supply Chain Management (Управление цепочками поставок). Существует несколько типов
          моделей управления цепочками поставок, включая **Continuous Flow Model**, **Agile Model**, **Fast Model** и **
          Flexible Model**[¹](https://www.investopedia.com/terms/s/scm.asp). Что еще вы хотели бы узнать?
    </details>

  #### 164. Для чего используют системы контроля версий?

    - <details><summary>Ответ:</summary>

        - Системы контроля версий используются для отслеживания и управления изменениями в коде и других файлах. Они
          помогают командам разработчиков управлять изменениями в исходном коде со временем. Системы контроля версий
          позволяют разработчикам сохранять несколько версий кода, возвращаться к любой предыдущей версии, работать
          параллельно, отслеживать изменения, синхронизировать код, копировать/объединять/отменять изменения и находить
          различия между версиями[¹](https://devopsbuzz.com/version-control-systems/). Что еще вы хотели бы узнать?

    </details>

  #### 165. Какие есть команды git?

    - <details><summary>Ответ:</summary>

        - Git - это распределенная система контроля версий, которая используется для отслеживания изменений в коде и
          других файлах. Существует множество команд Git, которые позволяют выполнять различные операции с репозиториями
          Git. Некоторые из самых часто используемых команд Git включают `git init`, `git clone`, `git add`
          , `git commit`, `git status`, `git push`, `git branch` и `git checkout`[¹](https://git-scm.com/docs/git). Вы
          можете узнать больше о каждой
          команде Git, используя команду `git help <command>`. Что еще вы хотели бы узнать?
    </details>

  #### 166. Какие этапы во время комита изменений?

    - <details><summary>Ответ:</summary>

        - Когда вы делаете коммит изменений в Git, происходит несколько этапов:
            1. **Добавление файлов в индекс**: Сначала вы должны добавить измененные файлы в индекс, используя
               команду `git add`. Это позволяет Git знать, какие файлы вы хотите включить в коммит.

            2. **Создание сообщения коммита**: Затем вы должны создать сообщение коммита, которое описывает изменения,
               которые вы сделали. Это можно сделать, используя команду `git commit` с флагом `-m`,
               например: `git commit -m "Описание изменений"`.

            3. **Сохранение изменений**: Наконец, Git сохраняет изменения в репозитории, создавая новый коммит с
               указанным сообщением и добавленными файлами.

        - Эти этапы позволяют Git точно отслеживать изменения в коде и обеспечивают возможность отката к предыдущим
          версиям кода при необходимости.
    </details>

  #### 167. Разница между git fetch и git pull?

    - <details><summary>Ответ:</summary>

        - `git fetch` и `git pull` - это две команды, которые используются для получения изменений из удаленного
          репозитория. Однако они работают немного по-разному.
        - `git fetch` используется для получения изменений из удаленного репозитория, но не объединяет их с локальными
          изменениями. Это позволяет вам просмотреть изменения, которые были сделаны в удаленном репозитории, перед тем
          как объединить их с локальными изменениями.
        - `git pull`, с другой стороны, используется для получения изменений из удаленного репозитория и автоматического
          объединения их с локальными изменениями. Это эквивалентно выполнению команд `git fetch`, а затем `git merge`.
        - Основная разница между этими двумя командами заключается в том, что `git fetch` позволяет вам просмотреть
          изменения перед их объединением, в то время как `git pull` автоматически объединяет изменения с локальными
          изменениями.

    </details>

  #### 168. Какие есть этапы решения merge conflict?

    - <details><summary>Ответ:</summary>

        - Merge conflict возникает, когда Git не может автоматически объединить изменения из двух разных веток. Это
          может произойти, когда два разработчика вносят изменения в один и тот же участок кода в одном и том же файле.
          Чтобы решить merge conflict, вы можете выполнить следующие шаги:
            1. **Определите, где произошел конфликт**: Сначала вы должны определить, в каких файлах произошел конфликт.
               Git обычно сообщает об этом при попытке выполнения слияния.
            2. **Откройте файлы с конфликтами**: Откройте файлы с конфликтами в текстовом редакторе и найдите места, где
               Git пометил конфликты. Они будут выделены специальными маркерами, такими как `<<<<<<<`, `=======`
               и `>>>>>>>`.

            3. **Решите конфликты**: Проанализируйте конфликтующие изменения и решите, какие из них должны быть
               сохранены. Вы можете выбрать одну из версий или объединить их вручную.

            4. **Сохраните изменения**: После того, как вы решили все конфликты, сохраните изменения в файле.

            5. **Зафиксируйте изменения**: Выполните команду `git add` для добавления измененных файлов в индекс, а
               затем выполните команду `git commit`, чтобы зафиксировать изменения.

        - Эти шаги позволят вам решить merge conflict и продолжить работу над проектом.
    </details>

---

- ### <span style="color:red">Практическая задача<span/>

  #### 169. Посчитайте количество единиц в произвольном числе.

    - <details><summary>Ответ:</summary>

      ```c++
      - Вот простой пример кода на C++, который показывает, как посчитать количество единиц в произвольном числе:

      -  ```c++
        #include <iostream>
        using namespace std;
        
        int main() {
            int n;
            cout << "Введите число: ";
            cin >> n;
            int count = 0;
            while (n > 0) {
                if (n % 2 == 1) {
                    count++;
                }
                n /= 2;
            }
            cout << "Количество единиц: " << count << endl;
            return 0;
        }
       ```

        - В этом примере мы считываем число с клавиатуры, а затем используем цикл `while` для перебора его битов. Если
          текущий бит равен 1, мы увеличиваем счетчик. В конце мы выводим полученное количество единиц.
    </details>

  #### 170. Есть структура по типу «односвязный список». Напишите функцию, которая разворачивает список. То есть, первый элемент становится последним, а последний - первым.

    - <details><summary>Ответ:</summary>

        - Вот пример функции на C++, которая разворачивает односвязный список:
        - ```c++
          struct Node {
            int data;
            Node* next;
          };
        
          void reverseList(Node*& head) {
            Node* prev = nullptr;
            Node* current = head;
            Node* next = nullptr;
            while (current != nullptr) {
                next = current->next;
                current->next = prev;
                prev = current;
                current = next;
            }
            head = prev;
          }
          ```

        - В этой функции мы используем три указателя: `prev`, `current` и `next`. Мы проходим по списку, меняя связи
          между узлами, чтобы развернуть список. В конце мы обновляем указатель на голову списка, чтобы он указывал на
          новую голову.

    </details>

  #### 171. Напишите реализацию функции int atoi (const char *str); преобразования строки в число.

    - <details><summary>Ответ:</summary>

        - ```c++
          int atoi(const char *str) {
               int result = 0; 
               int sign = 1;
               int i = 0;
               // Пропускаем пробелы
               while (str[i] == ' ') {
                  i++;
               }
              // Определяем знак числа
              if (str[i] == '-' || str[i] == '+') {
                sign = (str[i++] == '-') ? -1 : 1;
              }
              // Преобразуем строку в число
              while (str[i] >= '0' && str[i] <= '9') {
                result = result * 10 + (str[i++] - '0'); 
             } 
             return result * sign; 
          }

          ```
     </details>

  #### 172. Для структуры типа односвязный список напишите функцию вставки элемента.

    - <details><summary>Ответ:</summary>

        - Пример функции на C++, которая вставляет элемент в односвязный список:

            ```c++
            struct Node {
                int data;
                Node* next;
            };
            
            void insertNode(Node*& head, int data, int position) {
                Node* newNode = new Node{data, nullptr};
                if (position == 0) {
                    newNode->next = head;
                    head = newNode;
                } else {
                    Node* current = head;
                    for (int i = 0; i < position - 1 && current != nullptr; i++) {
                        current = current->next;
                    }
                    if (current != nullptr) {
                        newNode->next = current->next;
                        current->next = newNode;
                    }
                }
            }
            ```

        - В этой функции мы создаем новый узел с заданными данными, а затем вставляем его в список на указанную позицию.
          Если позиция равна 0, мы вставляем новый узел в начало списка. В противном случае мы ищем узел, который
          находится перед указанной позицией, и вставляем новый узел после него.
    </details>

  #### 173. Реализуйте класс vector.

    - <details><summary>Ответ:</summary>

        - ```c++
                  #include <iostream>
            
            
            template<typename T>
            class MyVector {
            private:
            T *arr_;
            long long capacity; // all reserve memory
            long long length_; //
            
            public:
            
                explicit MyVector(long long = 100);
            
                long long push_back(T);
            
                T pop_back();
            
                long long size() const;
            
                T &operator[](long long);
            
                class Iterator {
                    T *ptr_;
                public:
                    explicit Iterator() : ptr_(nullptr) {}
                    explicit Iterator(T*p) : ptr_(p) {}
            
                    bool operator==(const Iterator &rhs) const {
                        return ptr_ == rhs.ptr_;
                    }
            
                    bool operator!=(const Iterator &rhs) const {
                        return !(*this == rhs);
                    }
            
                    T operator*() const {
                        return *ptr_;
                    }
            
                    Iterator &operator++() {
                        ++ptr_;
                        return *this;
                    }
            
                    Iterator operator++(int) {
                        Iterator temp(*this);
                        ++*this;
                        return temp;
                    }
                };
            
                Iterator begin() const;
            
                Iterator end() const;
            };
           ```
        - source [code](https://github.com/Jollu8/Algorithms/blob/main/Containers/Vector.cpp)
     </details>

  #### 174. Реализуйте бинарный поиск в массиве.

    - <details><summary>Ответ:</summary>

        - ```c++
          int binarySearch(int arr[], int size, int target) {
            int left = 0;
            int right = size - 1;
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (arr[mid] == target) {
                    return mid;
                } else if (arr[mid] < target) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            return -1;
          }
          ```
        - В этой функции мы используем два указателя `left` и `right`, чтобы отслеживать текущий диапазон поиска. Мы
          вычисляем
          средний индекс `mid` и сравниваем значение в этом индексе с искомым значением. Если они равны, мы возвращаем
          индекс `mid`. Если значение в индексе `mid` меньше искомого значения, мы обновляем указатель `left`
          на `mid + 1`. В
          противном случае мы обновляем указатель `right` на `mid - 1`. Если значение не найдено, мы возвращаем -1.

    </details>

  #### 175. Реализуйте любую сортировку.

    - <details><summary>Ответ:</summary>

        - [All my sorts](https://github.com/Jollu8/Algorithms/tree/main/Sort)
    </details>

  #### 176. Реализуйте макрос для сравнения двух строк.

    - <details><summary>Ответ:</summary>

        -   ```c++
            #include <cstring>
            #define STRCMP(a, b) (strcmp((a), (b)) == 0)
            
            int main() {
                const char* str1 = "Hello";
                const char* str2 = "World";
                if (STRCMP(str1, str2)) {
                    // Строки равны
                } else {
                    // Строки не равны
                }
                return 0;
            }
            ```

        - В этом примере мы определяем макрос `STRCMP`, который использует функцию `strcmp` из стандартной библиотеки C
          для сравнения двух строк. Макрос возвращает `true`, если строки равны, и `false` в противном случае. Мы можем
          использовать этот макрос в коде для сравнения двух строк.

    </details>

  #### 177. Реализуйте реверс строк.

    - <details><summary>Ответ:</summary>

        - C++, который реализует реверс строки:

        -   ```c++
            #include <iostream>
            #include <string>
            using namespace std;
            
            int main() {
                string str;
                cout << "Введите строку: ";
                getline(cin, str);
                reverse(str.begin(), str.end());
                cout << "Реверсированная строка: " << str << endl;
                return 0;
            }
            ```
      Этот код считывает строку с консоли, используя функцию `getline`, затем использует функцию `reverse` из
      стандартной библиотеки C++ для реверсирования строки и выводит результат на экран. Вы можете скопировать этот код
      и запустить его в любом компиляторе C++.

    </details>

  #### 178. Реализуйте перевода числа из строки в int.

    - <details><summary>Ответ:</summary>

        - C++, который реализует перевод числа из строки в int:

        -   ```c++
            #include <iostream>
            #include <string>
            using namespace std;
            
            int main() {
                string str;
                cout << "Введите число: ";
                getline(cin, str);
                int num = stoi(str);
                cout << "Число в формате int: " << num << endl;
                return 0;
            }
             ```
            Этот код считывает строку с консоли, используя функцию `getline`, затем использует функцию `stoi` из
            стандартной библиотеки C++ для преобразования строки в число типа int и выводит результат на экран. Вы
            можете скопировать этот код и запустить его в любом компиляторе C++.
    </details>

  #### 179. Реализуйте подсчет слов в предложении.

    - <details><summary>ответ:</summary>

        - C++, который реализует подсчет слов в предложении:

        -  ```c++
            #include <iostream>
            #include <string>
            #include <sstream>
            using namespace std;
            
            int main() {
                string sentence;
                cout << "Введите предложение: ";
                getline(cin, sentence);
                stringstream ss(sentence);
                string word;
                int count = 0;
                while (ss >> word) {
                    count++;
                }
                cout << "Количество слов в предложении: " << count << endl;
                return 0;
            }
            ```

        - Этот код считывает предложение с консоли, используя функцию `getline`, затем использует класс `stringstream`
          из стандартной библиотеки C++ для разбиения предложения на слова и подсчета их количества. Результат выводится
          на экран. Вы можете скопировать этот код и запустить его в любом компиляторе C++.
    </details>

  #### 180. Реализуйте подсчет чисел Фибоначчи.

    - <details><summary>Ответ:</summary>

        - Конечно! Вот простой код на C++, который реализует подсчет чисел Фибоначчи:

        -   ```c++
            #include <iostream>
            using namespace std;
            
            int main() {
                int n;
                cout << "Введите количество чисел Фибоначчи: ";
                cin >> n;
                int a = 0, b = 1;
                cout << "Первые " << n << " чисел Фибоначчи: ";
                for (int i = 0; i < n; i++) {
                    cout << a << " ";
                    int c = a + b;
                    a = b;
                    b = c;
                }
                cout << endl;
                return 0;
            }
            ```

        - Этот код считывает количество чисел Фибоначчи, которые нужно вывести, затем использует цикл для подсчета и
          вывода первых `n` чисел Фибоначчи. Вы можете скопировать этот код и запустить его в любом компиляторе C++.
    </details>

  #### 181. Найдите такие элементы двух массивов, которые попадаются только в каждом из них. Желательно использовать STL.

    - <details><summary>Ответ:</summary>

        - C++, который реализует поиск элементов, которые встречаются только в одном из двух массивов, используя STL:

        -    ```c++
              #include <iostream>
              #include <vector>
              #include <algorithm>
              using namespace std;
              
              int main() {
                  vector<int> v1 = {1, 2, 3, 4, 5};
                  vector<int> v2 = {4, 5, 6, 7, 8};
                  vector<int> result;
                  set_symmetric_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), back_inserter(result));
                  cout << "Элементы, которые встречаются только в одном из двух массивов: ";
                  for (int x : result) {
                      cout << x << " ";
                  }
                  cout << endl;
                  return 0;
              } 
              ```

        - Этот код использует функцию `set_symmetric_difference` из стандартной библиотеки C++ для нахождения элементов,
          которые встречаются только в одном из двух массивов. Результат выводится на экран. Вы можете скопировать этот
          код и запустить его в любом компиляторе C++.
     </details>

  #### 182. Удалите из unordered_map элементы, которые делятся на 2 и выведите ключи этих элементов.

    - <details><summary>Ответ:</summary>

        -   ```c++
            #include <iostream>
            #include <unordered_map>
            using namespace std;
            
            int main() {
                unordered_map<int, int> m = {{1, 3}, {2, 4}, {3, 6}, {4, 8}};
                cout << "Ключи удаленных элементов: ";
                for (auto it = m.begin(); it != m.end();) {
                    if (it->second % 2 == 0) {
                        cout << it->first << " ";
                        it = m.erase(it);
                    } else {
                        ++it;
                    }
                }
                cout << endl;
                return 0;
            }
            ```

        - Этот код создает `unordered_map` с некоторыми элементами, затем использует цикл для обхода всех элементов и
          удаления тех, которые делятся на 2. Ключи удаленных элементов выводятся на экран. Вы можете скопировать этот
          код и запустить его в любом компиляторе C++.
     </details>

  #### 183. Напишите класс для логирования, который мог бы логировать к консоли или файлу.

    - <details><summary>Ответ:</summary>

        - ```c++
            #include <iostream>
            #include <fstream>
            #include <string>
            using namespace std;
            
            class Logger {
            public:
                enum class OutputType { Console, File };
                Logger(OutputType outputType, const string& fileName = "") : outputType(outputType), fileName(fileName) {}
                void log(const string& message) {
                    if (outputType == OutputType::Console) {
                        cout << message << endl;
                    } else {
                        ofstream file(fileName, ios::app);
                        file << message << endl;
                    }
                }
            private:
                OutputType outputType;
                string fileName;
            };
            
            int main() {
                Logger logger1(Logger::OutputType::Console);
                logger1.log("Сообщение в консоль");
                Logger logger2(Logger::OutputType::File, "log.txt");
                logger2.log("Сообщение в файл");
                return 0;
            }
            ```

        - Этот код определяет класс `Logger`, который имеет метод `log` для записи сообщения в консоль или файл. Вы
          можете создать объект класса `Logger`, указав тип вывода (консоль или файл) и имя файла (если тип вывода -
          файл). Затем вы можете использовать метод `log` для записи сообщений. Вы можете скопировать этот код и
          запустить его в любом компиляторе C++.
    </details>

  #### 184. Напишите функцию для определения, является ли определенный год високосным.

    - <details><summary>Ответ:</summary>

        - ```c++
            #include <iostream>
            using namespace std;
            
            bool isLeapYear(int year) {
                if (year % 400 == 0) {
                    return true;
                } else if (year % 100 == 0) {
                    return false;
                } else if (year % 4 == 0) {
                    return true;
                } else {
                    return false;
                }
            }
            
            int main() {
                int year;
                cout << "Введите год: ";
                cin >> year;
                if (isLeapYear(year)) {
                    cout << year << " является високосным годом" << endl;
                } else {
                    cout << year << " не является високосным годом" << endl;
                }
                return 0;
            } 
          ```

        - Этот код определяет функцию `isLeapYear`, которая принимает год в качестве параметра и возвращает `true`, если
          год является високосным, и `false` в противном случае. Функция использует правила для определения високосного
          года: если год делится на 400, то он является високосным; если год делится на 100, то он не является
          високосным; если год делится на 4, то он является високосным; в противном случае он не является високосным. Вы
          можете скопировать этот код и запустить его в любом компиляторе C++.
     </details>

  #### 185. Напишите функцию для определения, является ли определенное слово палиндромом.
    - <details><summary>Ответ:</summary>

        - ```c++
            #include <iostream>
            #include <string>
            #include <algorithm>
            using namespace std;
            
            bool isPalindrome(const string& word) {
                string reversedWord = word;
                reverse(reversedWord.begin(), reversedWord.end());
                return word == reversedWord;
            }
            
            int main() {
                string word;
                cout << "Введите слово: ";
                cin >> word;
                if (isPalindrome(word)) {
                    cout << word << " является палиндромом" << endl;
                } else {
                    cout << word << " не является палиндромом" << endl;
                }
                return 0;
            }
          ```

        - Этот код определяет функцию `isPalindrome`, которая принимает слово в качестве параметра и возвращает `true`,
          если слово является палиндромом, и `false` в противном случае. Функция создает копию слова, затем использует
          функцию `reverse` из стандартной библиотеки C++ для реверсирования копии и сравнивает ее с исходным словом.
          Если они равны, то слово является палиндромом. Вы можете скопировать этот код и запустить его в любом
          компиляторе C++.
     </details>

  #### 186. Напишите реализацию паттерна Singleton.

    - <details><summary>Ответ:</summary>

        - ```c++
            #include <iostream>
            using namespace std;
            
            class Singleton {
            public:
                static Singleton& getInstance() {
                    static Singleton instance;
                    return instance;
                }
                void someMethod() {
                    cout << "Вызов метода someMethod" << endl;
                }
            private:
                Singleton() {}
                Singleton(const Singleton&) = delete;
                Singleton& operator=(const Singleton&) = delete;
            };
            
            int main() {
                Singleton::getInstance().someMethod();
                return 0;
            }
          ```
        - Этот код определяет класс `Singleton`, который имеет статический метод `getInstance` для получения
          единственного экземпляра класса. Конструктор класса `Singleton` является приватным, чтобы предотвратить
          создание дополнительных экземпляров класса. Кроме того, операторы копирования и присваивания также являются
          приватными и удалены, чтобы предотвратить копирование экземпляра класса. Вы можете использовать
          метод `getInstance` для получения единственного экземпляра класса `Singleton` и вызова его методов. Вы можете
          скопировать этот код и запустить его в любом компиляторе C++.

     </details>

  #### 187. Напишите реализацию std::vector с операциями: push_back, push_front, pop_back, pop_front, size, clear.

    - <details><summary>Отвте:</summary>

        - Код убрал [отдельно](Codes/junior/jcode_187.cpp) по причине, что он
          слишком [большой](https://github.com/Jollu8/Algorithms/blob/main/Containers/Vector.cpp)
        - Этот код определяет шаблонный класс MyVector, который имеет методы для добавления и удаления элементов с
          начала и конца вектора, а также методы для получения размера вектора и очистки его. Класс использует
          динамический массив для хранения элементов и автоматически увеличивает его размер при необходимости. Вы можете
          использовать этот класс как обычный вектор, вызывая его методы для работы с элементами. Вы можете скопировать
          этот код и запустить его в любом компиляторе C++.
     </details>

  #### 188. Напишите рекурсивный поиск значения в дереве бинарного поиска.

    - <details><summary>Ответ:</summary>

        - ```c++
            struct Node {
                int value;
                Node *left;
                Node *right;
            };
            
            bool search(Node* root, int value) {
                if (root == nullptr) {
                    return false;
                }
                if (root->value == value) {
                    return true;
                }
                if (value < root->value) {
                    return search(root->left, value);
                } else {
                    return search(root->right, value);
                }
            }
            ```

        - В этом коде функция `search` принимает указатель на корень дерева и значение, которое нужно найти. Если корень
          равен `nullptr`, то возвращается `false`, так как значение не может быть найдено. Если значение корня равно
          искомому
          значению, то возвращается `true`. В противном случае функция вызывается рекурсивно для левого или правого
          поддерева в
          зависимости от того, меньше или больше искомое значение значения корня. Этот процесс продолжается до тех пор,
          пока не
          будет найдено искомое значение или не будет достигнут конец дерева.
    </details>

  #### 189. Напишите функцию, которая проверяет, является ли дерево сбалансированным.
    - <details><summary>Ответ:</summary>

        ```c++
             struct Node {
                int data;
                Node *left;
                Node *right;
                };
            
            bool isBalanced(Node *root, int &height) {
            if (root == nullptr) {
            height = 0;
            return true;
            }
            
                int leftHeight = 0, rightHeight = 0;
                bool leftBalanced = isBalanced(root->left, leftHeight);
                bool rightBalanced = isBalanced(root->right, rightHeight);
            
                height = max(leftHeight, rightHeight) + 1;
            
                if (abs(leftHeight - rightHeight) > 1) {
                    return false;
                }
            
                return leftBalanced && rightBalanced;
            }
         ```

        - В этом коде функция isBalanced принимает указатель на корень дерева и ссылку на переменную height, в которой
          будет храниться высота дерева. Функция возвращает true, если дерево сбалансировано, и false в противном
          случае. Внутри функции рекурсивно вызывается для левого и правого поддеревьев и проверяется разница между
          высотами левого и правого поддеревьев. Если эта разница больше 1, то дерево не сбалансировано. В противном
          случае функция возвращает логическое И между результатами вызовов для левого и правого поддеревьев. Если оба
          поддерева сбалансированы, то и всё дерево сбалансировано. 😊
    </details>

  #### 190. Напишить функцию для поиска уникального элемента в массиве.

    - <details><summary>Ответ:</summary>

        - Чтобы найти уникальный элемент в массиве, можно использовать различные алгоритмы. Один из простых способов -
          это использование хэш-таблицы для подсчета количества вхождений каждого элемента в массив. Затем можно
          пройтись по хэш-таблице и найти элемент, который встречается только один раз.
        - Вот пример кода на C++, который реализует этот алгоритм:

        -  ```c++
            #include <unordered_map>
            #include <vector>
            
            int findUnique(const std::vector<int> &arr) {
                std::unordered_map<int, int> count;
                for (int x : arr) {
                    count[x]++;
                }
                for (int x : arr) {
                    if (count[x] == 1) {
                        return x;
                    }
                }
                return -1; // если уникального элемента нет
            }
           ```

        - В этом коде функция `findUnique` принимает вектор `arr` и возвращает уникальный элемент в этом массиве. Если
          такого элемента нет, то функция возвращает `-1`. Внутри функции создается хэш-таблица `count`, в которой
          хранится количество вхождений каждого элемента в массив. Затем происходит двойной проход по массиву: сначала
          для подсчета количества вхождений каждого элемента, а затем для поиска элемента, который встречается только
          один раз. Этот алгоритм имеет временную сложность O(n) и пространственную сложность O(n), где n - размер
          массива. 😊
      ```
    </details>


([Автор вопросов](https://dou.ua/lenta/articles/interview-questions-c-developer/))
