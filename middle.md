# Middle

- ## <span style="color:red">Общее</span>

  #### 1. Какие курсы прошли или книги прочитали за этот год? Чему научились?

    - <details><summary>Ответ:</summary>

        - Otus [C++ professional](otus.ru)
        - intel [multithreading](https://www.intel.com/content/www/us/en/support/ru-banner-inside.html)
        - [coding-interview-university](https://github.com/jwasham/coding-interview-university)
        - [Algorithms](https://github.com/Jollu8/Algorithms)
        - [LeetCode](https://leetcode.com/)
    </details>

  ---

  #### 2. Что нравится и не нравится в С++? Чего не хватает?

    - <details><summary>Ответ:</summary>

        - likes
            - Smart pointers
            - Pointers
            - free memory
            - OOP
            - C++
            - Data race
            - STL
            - Algorithms

        - Unlike
            - Pointers
            - C++
            - My life
    </details>

  ---

  #### 3. Что интересного нашли в новых стандартах С++17, С++20 (конкретные фичи)?

    - <details><summary>Ответ:</summary>

        - C++17
            - Nested Namespaces
            - Variable declaration in if and switch
            - if constexpr statement
            - Structured bindings
            - Fold Expressions
            - Direct list initialization of enums

        - C++20
            - C++ Concepts library
            - 3-way comparisons
            - Map contains
            - Range-based for loop
            - New identifiers ( import, module)
            - Calendar and time zone library
            - std::string functions
            - Array bounded/unbounded
            - std::to_array
            - Likely and unlikely attributes
    </details>

  ---

  #### 4. Расскажите о фичах, которые появились в разных версиях языка.

    - <details><summary>Ответ:</summary>

        - C++ best [futures](https://en.cppreference.com/w/cpp/standard_library)
    </details>

  ---

  #### 5. Расскажите о модели памяти, которая появилась в С++11 стандарте.

    - <details><summary>Ответ:</summary>

        - Модель памяти была разработана для C++11 и принята C11. Лоуренс Кроул проделал большую работу, чтобы интерфейс
          для атомарных операций был как можно ближе.
        - ##### Модель памяти С++ 11
            - Модель памяти, также известная как модель согласованности памяти, представляет собой спецификацию
              допустимого поведения многопоточных программ, выполняющихся с общей памятью. Самой базовой моделью
              является последовательная согласованность (SC), где все инструкции из всех потоков (кажутся) формируют
              общий порядок, который согласуется с порядком программы в каждом потоке.

            - Одной из наиболее важных особенностей C++11 является предоставление модели памяти с поддержкой
              многопоточности, которая позволяет писать многопоточные программы, не полагаясь на расширения для
              конкретной платформы.
            - Sequential consistency
                - SC означает, что все потоки соглашаются с порядком выполнения операций с памятью, и этот порядок
                  согласуется с порядком операций в исходном коде программы.
                - Некоторые языки программирования предлагают SC в многопроцессорной среде. В C++11 вы можете объявить
                  все общие переменные как атомарные типы C++11 с ограничениями порядка использования памяти по
                  умолчанию. В Java вы можете пометить все общие переменные как volatile[ 1 ] [ 2 ].
                - Компилятор вставляет дополнительные инструкции за кулисами, например, ограничения памяти, чтобы
                  обеспечить соблюдение порядка.

                ```c++
                std::atomic<int> x(0), y(0);
                //thread1
                x = 1;
                //thread2
                y = 1;
                //thread3
                if(x==1 && y==0)
                    print ("x first");
                //thread4
                if(y==1 && x==0)
                    print ("y first");
                // Атомарные типы C++11 гарантируют SC, поэтому для вывода обоих сообщений требуется impsbl.
                ```
                - [1. Последовательная согласованность_1](http://bartoszmilewski.com/2008/11/11/who-ordered-sequential-consistency/)
                - [2. Последовательная согласованность_2](http://preshing.com/20120612/an-introduction-to-lock-free-programming/#sequential-consistency)
            - Concurrency needs sync
                - Для повышения производительности современные процессоры часто выполняют инструкции не по порядку,
                  чтобы полностью использовать ресурсы. Поскольку аппаратное обеспечение обеспечивает целостность
                  инструкций, мы никогда не заметим этого при выполнении одного потока. Однако для нескольких потоков
                  это может привести к непредсказуемому поведению.
                - При многопоточном выполнении неконтролируемое планирование приводит к гонке данных, где результаты
                  зависят от времени выполнения кода. При некотором невезении (например, при переключении контекста в
                  несвоевременные моменты выполнения) мы получаем неверный результат.
                - (i) взаимное исключение ( атомарное )
                - Для достижения атомарности мы можем запросить у аппаратного обеспечения несколько полезных инструкций
                  для построения взаимного исключения, которое гарантирует, что если один поток выполняется в
                  критической секции, другие не смогут этого сделать.
                - (ii) ожидание другого ( условная переменная)
                - Во многих случаях поток продолжает свое выполнение только при выполнении некоторого условия . Таким
                  образом, один поток должен ждать, пока другой завершит какое-либо действие, прежде чем
                  продолжить.
                - [1. Потоки OSTEP](http://pages.cs.wisc.edu/~remzi/OSTEP/threads-intro.pdf)
                - [2. Условная переменная OSTEP](http://pages.cs.wisc.edu/~remzi/OSTEP/threads-cv.pdf)
                - [3. Условная переменная Wiki](http://en.cppreference.com/w/cpp/thread/condition_variable)
                - [4. Ограждение памяти](http://stackoverflow.com/questions/286629/what-is-a-memory-fence)
            - Memory ordering is crucial
                - Порядок операций с памятью в системе по умолчанию очень расслаблен, и ЦП имеет большую свободу
                  переупорядочивать операции, и компиляторы также могут располагать инструкции, которые он выдает, в
                  любом порядке, который им нравится, при условии, что это не влияет на очевидную работу программы.
                - В многопоточном сценарии, чтобы избежать условий гонки, следует применять порядок доступа из разных
                  потоков.
                - (i) Ограниченные гарантии ЦП
                  на любом ЦП зависимые обращения к памяти будут выполняться по порядку;
                  перекрывающиеся загрузки и сохранения внутри определенного ЦП будут казаться упорядоченными внутри
                  этого ЦП;
                  перекрывающиеся обращения к памяти могут быть объединены или отброшены.
                  (ii) преобразование кода
                  ЦП и другие устройства в системе могут использовать различные приемы для повышения производительности,
                  включая переупорядочивание, отсрочку и комбинацию операций с памятью; спекулятивные нагрузки;
                  спекулятивное предсказание переходов и различные виды кэширования.
                - оптимизация компилятора
                  что знает компилятор
                  --> все операции с памятью в этом потоке и что именно они делают, включая зависимости данных;
                  --> как быть достаточно консервативным перед лицом псевдонимов psbl
                  что не знает
                  --> какие ячейки памяти являются "изменяемыми общими" переменными и могут изменяться асинхронно из-за
                  операции с памятью
                  в другом потоке
                  --> как быть достаточно консервативным перед лицом совместного использования psbl
                  решение: скажите --> каким-то образом определите операции над "изменяемыми общими" локациями
                  Независимые операции с памятью эффективно выполняются в случайном порядке, но это может быть проблемой
                  для
                  взаимодействия CPU-CPU и для ввода-вывода, и, следовательно, нам нужен порядок.
                - (iii) заказ является контрактом
                  Вы обещаете: правильно синхронизировать вашу программу (без условий гонки)
                  «Система» обещает: обеспечить иллюзию выполнения написанной вами программы
            - Ordering techniques
                - Чтобы гарантировать SC, вы должны подумать, как предотвратить переупорядочивание памяти. Пути могут
                  быть облегченной синхронизацией или ограждением , полным ограждением или семантикой
                  приобретения/освобождения .
                - Хранилище выпуска делает свои предыдущие доступы видимыми для потока, выполняющего загрузку, который
                  видит (сопряжение) с этим хранилищем .
                - Автоматизация получения и выпуска:
                  --> не пишите заборы вручную.
                  --> заставьте компилятор писать барьеры для вас, используя абстракции «критической области»: мьютексы
                  и переменные std::
                  atomic<> .
                - (i) #1: используйте мьютексы
                  используйте блокировки мьютекса для защиты кода, который читает/записывает общие переменные.
                  Плюсы:
                  Минусы: требует осторожности при каждом использовании общих переменных.
                - ```c++
                  //Lock acquire/release:
                  mut_x.lock(); //"acquire" mut_x ==> ld.acq mut_x
                  ... read/write x ...
                  mut_x.unlock(); //"release" mut_x ==> st.rel mut_x
                  ```
                - (ii) #2: std::atomic<>
                  специальные атомарные типы автоматически защищены от переупорядочения.
                  Плюсы: просто пометьте переменную, а не везде, где она используется. Минусы: написать правильный
                  атомарный код сложнее, чем кажется.
                - ```c++
                  std::atomics: read=acquire, write=release
                  while(whose_turn != me){} //read whose_turn ==> ld.acq whose_turn
                  ... read/write x ...
                  whose_turn = someone_else; //write whose_turn ==> st.rel whose_turn
                  ```
                - (iii) #3: заборы и заказанные API
                  Ограждение/барьер памяти — это класс инструкций, обеспечивающих загрузку/сохранение памяти в ожидаемом
                  порядке. В
                  отличие от мьютексов высокого уровня и атомарных объектов, ограничения памяти зависят от аппаратного
                  обеспечения.

                - Свободное от
                    - блокировок программирование Свободная от блокировок программа никогда не может быть полностью
                      остановлена ​​ни одним
                      потоком. Полная «блокировка» может быть любой, например, тупиковой, живой или даже злонамеренной
                      диспетчерской.

                - [1. Последовательная согласованность](http://preshing.com/20120612/an-introduction-to-lock-free-programming/#sequential-consistency)
                - [2. Блокировка свободного программирования](http://stackoverflow.com/questions/14011849/lock-free-multithreaded-programming)
                - [3. Получение и освобождение семантики](http://preshing.com/20120913/acquire-and-release-semantics/)
            - Object layout
                - Все данные в программе C++ состоят из объектов , каждый из которых представляет собой «область
                  хранения».
                  Объекты могут быть простого фундаментального типа, такого как int или float , а также могут быть
                  экземплярами определяемых пользователем классов.
                  Независимо от типа объект хранится в одной или нескольких ячейках памяти . Каждая такая ячейка памяти
                  является либо объектом (или подобъектом) скалярного типа, например, short или my_class* , либо
                  последовательностью смежных.
                - Каждая переменная является объектом, включая те, которые являются членами других объектов.
                  Каждый объект занимает как минимум одну ячейку памяти.
                  Переменные фундаментального типа (например, int или char ) представляют собой точно одну ячейку
                  памяти, независимо от их размера, даже если они являются смежными или являются частью массива.
                  Смежные битовые поля являются частью одной и той же ячейки памяти.
                  Учитывая две глобальные переменные char c и char d :
                - ```c++
                  //Thread 1
                  { lock_guard<mutex> lock(cMutex);
                      c = 1;
                  }
                  //Thread 2
                  { lock_guard<mutex> lock(dMutex);
                      d = 1;
                  }
                  ```
                - В идеальном C++11 нет расы, но в реальной жизни это psbl (например, и смежные битовые поля как один
                  объект):
                - ```c++
                  //system lays out c then d contiguously
                  char tmp[4]; //32-bit scratchpad
                  memcpy(&tmp[0], &c, 4); //read 32b starting at c
                  tmp[1] = 1; //set only bits of d
                  memcpy(&c, &temp[0], 4); //write 32 bits back
                  //thread 2 sliently also write to c without holding cMutex
                  ```
              [1. Битовое поле](http://en.cppreference.com/w/cpp/language/bit_field)
              [2. Ложное совместное использование](https://software.intel.com/en-us/articles/avoiding-and-identifying-false-sharing-among-threads)
                - Спекуляция и размещение реестра
                    - предположение:
                      система (компилятор, ЦП, кеш, ...) предполагает, что условие может быть истинным (например,
                      предсказание ветвления),
                      или имеет основания полагать, что условие часто верно (например, оно было истинным последние 100
                      раз). мы выполнили
                      этот код)
                      Чтобы сэкономить время, мы можем оптимистично начать дальнейшее выполнение, основываясь на этом
                      предположении. Если
                      это правильно, мы сэкономили время. Если это неправильно, мы должны отменить любую спекулятивную
                      работу.
                    - ```c++
                      if(cond)    | {
                           lock x | unique_lock<mutex> hold(mut, defer_lock)
                              ... | if(cond)
                      if(cond)    | hold.lock();
                            use x | ...
                              ... | if(cond)
                      if(cond)    | use x
                         unlock x | ...
                                  | }//as-if "if(cond) hold.unlock()"
                      ```
                    - Приведенный выше общий шаблон безопасен для MM C++11. Но остерегайтесь ошибок компилятора...
                    - ```c++
                      //x is a shared var
                      if(cond)
                      x = 42;
                      //cond is speculated to be true, rewrite code
                      r1 = x; //read what's there
                      x = 42; //oops: optimistic write is NOT conditional
                      if(!cond) //check if we guessed wrong
                      x = r1; //oops: back-out write is NOT sc
                - размещение регистра
                - условные блокировки :
                  --> Проблема: ваш код использует блокировку по условию, но в вашей системе есть ошибка , которая
                  изменяет условную
                  запись на безусловную.
            - C++11 techniques
                - (i) std::lock_guard
                  Класс lock_guard — это оболочка мьютекса, предоставляющая удобный механизм в стиле RAII для владения
                  мьютексом на время действия блока с областью действия.
                  Когда создается объект защиты блокировки, он пытается завладеть предоставленным ему мьютексом. Когда
                  управление покидает область, в которой был создан объект защиты блокировки, блокировка_защиты
                  разрушается, а мьютекс освобождается.
                - ```c++
                  #include <thread>
                  #include <mutex>
                  #include <iostream>
    
                  int g_i = 0;
                  std::mutex g_i_mutex; //protects g_i
    
                  void safe_incremenet(){
                      std::lock_guard<std::mutex> lock(g_i_mutex);
                      ++g_i;
                      std::cout << std::this_thread::get_id() << ":" << g_i << '\n';
     
                      //g_i_mutex is automically released when lock goes out of scope
                  }
    
                  int main(){
                      std::cout << __func__ << ": " << g_i << '\n';
                      std::thread t1(safe_increment);
                      std::thread t2(safe_increment); 
                      t1.join();
                      t2.join(); 
                      std::cout << __func__ << ": " << g_i << '\n';
                  }
                  ```
                - (ii) Используйте std::atomic для параллелизма
                  Экземпляры шаблона std::atomic предлагают операции, которые гарантированно будут восприниматься
                  другими потоками как атомарные . После создания объекта std::atomic операции над ним ведут себя так,
                  как если бы они находились внутри критической секции, защищенной мьютексом, но операции обычно
                  реализуются с использованием специальных машинных инструкций, которые более эффективны, чем в случае,
                  если бы мьютекс был занят.
                - ```c++
                  std::atomic<int> ai(0); //init ai to 0
                  ai = 10; //atomically set ai to 10
                  std::cout << ai; //atomically read ai's value
                  ++ai; //atomically increment ai to 11
                  --ai; //atomically decrement ai to 10
                  ```
                - Во время выполнения этих операторов другие потоки, читающие ai, могут видеть только значения 0, 10 или
                  11 . Никакие
                  другие значения невозможны (предположим, что это единственный поток, изменяющий ai).
                - std::atomic гарантирует только то, что чтение ai является атомарным, но не гарантирует, что весь
                  оператор будет
                  выполняться атомарно.
                - Между моментом чтения значения ai и вызовом оператора << для записи в стандартный вывод другой поток
                  мог изменить
                  значение ai.
                - после создания объекта std::atomic все его функции-члены, в том числе содержащие операции RMW,
                  гарантированно будут
                  восприниматься другими потоками как атомарные.
            - (iii) Непереносимые функции по своей сути
              Для поддержки низкоуровневого программирования C++ определяет некоторые функции, зависящие от машины.
                - Битовые поля
                  Битовое поле содержит определенное количество битов, а структура памяти битового поля зависит от
                  машины.
                - volatile
                  Ключевое слово volatile указывает компилятору, что он не должен выполнять оптимизацию таких объектов.
            - потоки С++
                - (1) Управление потоками
                - (i) базовое управление
                  detach thread
                  отсоединяет поток, представленный объектом, от вызывающего потока, позволяя им выполняться независимо
                  друг от друга.
                  Оба потока продолжают работать без блокировки и синхронизации.
                  Когда любой из них завершает выполнение, его ресурсы освобождаются.

                - Вызов detach() для объекта потока оставляет поток работать в фоновом режиме, и к нему больше нельзя
                  присоединиться.

                - join thread
                  Функция возвращается после завершения выполнения потока.

                - передача владения потоком std::thread t2=std::move(t1)

                - [1 Отделение нити](http://www.cplusplus.com/reference/thread/thread/detach/)
                - [2 Соединение нити](http://www.cplusplus.com/reference/thread/thread/join/)
                - ```c++
                  //compile: -std=c++0x -pthread
                  //the func we want to execute on the new thread
                  void task1(string msg){
                      cout << "task1 says: " << msg;
                  }

                  int main(){
                      //constructs the new thread and runs it
                      //form: thread(Function&& f, Args&&... args);
                      thread t1(task1, "Hello");

                      //makes the main thread wait for the new thread to finish, then continue
                      t1.join();
                  }
                  ```
                - ```c++
                  void pause_thread(int n){
                      std::this_thread::sleep_for (std::chrono::seconds(n));
                      std::cout << "pause of " << n << " seconds ended\n";
                  }

                  int main(){
                      std::cout << "spawning and detaching 3 threads ...\n";
                      std::thread(pause_thread, 1).detach();
                      std::thread(pause_thread, 2).detach();
                      std::thread(pause_thread, 3).detach();

                      std::cout << "Done spawning thread.\n";
                      //give the detached threads time to finish, but no guarantee
                      pause_thread(5);
                      return 0;
                  }
                  ```
    </details>

  ---

  #### 6. Что такое сериализация? Какие библиотеки знаете?

    - <details><summary>Ответ:</summary>

        - [Сериализация](https://habr.com/ru/post/479462/) — процесс перевода структуры данных в последовательность
          байтов. Обратной к операции сериализации
          является операция десериализации — создание структуры данных из битовой последовательности. Сериализация
          используется для передачи объектов по сети и для сохранения их в файлы.

    </details>

  ---

  #### 7. Какие знаете паттерны проектирования?

    - <details><summary>Ответ:</summary>

        - Ссылка на [материал](https://cpphinditutorials.com/dev-cpp/16-basic-patterns-programs-in-cpp/)
        - [GoF](http://www.dre.vanderbilt.edu/~schmidt/qualcomm/GoF-patterns.html)
    </details>

  ---  

  #### 8. Что такое операционная система? Какие существуют типы по назначению?

    - <details><summary>Ответ:</summary>
  
      
    </details>