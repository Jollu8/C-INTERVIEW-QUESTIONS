# Middle

- ## <span style="color:red">Общее</span>

  #### 1. Какие курсы прошли или книги прочитали за этот год? Чему научились?

    - <details><summary>Ответ:</summary>

        - Otus [C++ professional](otus.ru)
        - intel [multithreading](https://www.intel.com/content/www/us/en/support/ru-banner-inside.html)
        - [coding-interview-university](https://github.com/jwasham/coding-interview-university)
        - [Algorithms](https://github.com/Jollu8/Algorithms)
        - [LeetCode](https://leetcode.com/)
    </details>

  ---

  #### 2. Что нравится и не нравится в С++? Чего не хватает?

    - <details><summary>Ответ:</summary>

        - likes
            - Smart pointers
            - Pointers
            - free memory
            - OOP
            - C++
            - Data race
            - STL
            - Algorithms
            - I love my life because of C++

        - Unlike
            - Pointers
            - C++
            - I hate my life because it has to do with C++
    </details>

  ---

  #### 3. Что интересного нашли в новых стандартах С++17, С++20 (конкретные фичи)?

    - <details><summary>Ответ:</summary>

        - C++17
            - Nested Namespaces
            - Variable declaration in if and switch
            - if constexpr statement
            - Structured bindings
            - Fold Expressions
            - Direct list initialization of enums

        - C++20
            - C++ Concepts library
            - 3-way comparisons
            - Map contains
            - Range-based for loop
            - New identifiers ( import, module)
            - Calendar and time zone library
            - std::string functions
            - Array bounded/unbounded
            - std::to_array
            - Likely and unlikely attributes
    </details>

  ---

  #### 4. Расскажите о фичах, которые появились в разных версиях языка.

    - <details><summary>Ответ:</summary>

        - C++ best [futures](https://en.cppreference.com/w/cpp/standard_library)
    </details>

  ---

  #### 5. Расскажите о модели памяти, которая появилась в С++11 стандарте.

    - <details><summary>Ответ:</summary>

        - Модель памяти была разработана для C++11 и принята C11. Лоуренс Кроул проделал большую работу, чтобы интерфейс
          для атомарных операций был как можно ближе.
        - ##### Модель памяти С++ 11
            - Модель памяти, также известная как модель согласованности памяти, представляет собой спецификацию
              допустимого поведения многопоточных программ, выполняющихся с общей памятью. Самой базовой моделью
              является последовательная согласованность (SC), где все инструкции из всех потоков (кажутся) формируют
              общий порядок, который согласуется с порядком программы в каждом потоке.

            - Одной из наиболее важных особенностей C++11 является предоставление модели памяти с поддержкой
              многопоточности, которая позволяет писать многопоточные программы, не полагаясь на расширения для
              конкретной платформы.
            - Sequential consistency
                - SC означает, что все потоки соглашаются с порядком выполнения операций с памятью, и этот порядок
                  согласуется с порядком операций в исходном коде программы.
                - Некоторые языки программирования предлагают SC в многопроцессорной среде. В C++11 вы можете объявить
                  все общие переменные как атомарные типы C++11 с ограничениями порядка использования памяти по
                  умолчанию. В Java вы можете пометить все общие переменные как volatile[ 1 ] [ 2 ].
                - Компилятор вставляет дополнительные инструкции за кулисами, например, ограничения памяти, чтобы
                  обеспечить соблюдение порядка.

                ```c++
                std::atomic<int> x(0), y(0);
                //thread1
                x = 1;
                //thread2
                y = 1;
                //thread3
                if(x==1 && y==0)
                    print ("x first");
                //thread4
                if(y==1 && x==0)
                    print ("y first");
                // Атомарные типы C++11 гарантируют SC, поэтому для вывода обоих сообщений требуется impsbl.
                ```
                - [1. Последовательная согласованность_1](http://bartoszmilewski.com/2008/11/11/who-ordered-sequential-consistency/)
                - [2. Последовательная согласованность_2](http://preshing.com/20120612/an-introduction-to-lock-free-programming/#sequential-consistency)
            - Concurrency needs sync
                - Для повышения производительности современные процессоры часто выполняют инструкции не по порядку,
                  чтобы полностью использовать ресурсы. Поскольку аппаратное обеспечение обеспечивает целостность
                  инструкций, мы никогда не заметим этого при выполнении одного потока. Однако для нескольких потоков
                  это может привести к непредсказуемому поведению.
                - При многопоточном выполнении неконтролируемое планирование приводит к гонке данных, где результаты
                  зависят от времени выполнения кода. При некотором невезении (например, при переключении контекста в
                  несвоевременные моменты выполнения) мы получаем неверный результат.
                - (i) взаимное исключение ( атомарное )
                - Для достижения атомарности мы можем запросить у аппаратного обеспечения несколько полезных инструкций
                  для построения взаимного исключения, которое гарантирует, что если один поток выполняется в
                  критической секции, другие не смогут этого сделать.
                - (ii) ожидание другого ( условная переменная)
                - Во многих случаях поток продолжает свое выполнение только при выполнении некоторого условия . Таким
                  образом, один поток должен ждать, пока другой завершит какое-либо действие, прежде чем
                  продолжить.
                - [1. Потоки OSTEP](http://pages.cs.wisc.edu/~remzi/OSTEP/threads-intro.pdf)
                - [2. Условная переменная OSTEP](http://pages.cs.wisc.edu/~remzi/OSTEP/threads-cv.pdf)
                - [3. Условная переменная Wiki](http://en.cppreference.com/w/cpp/thread/condition_variable)
                - [4. Ограждение памяти](http://stackoverflow.com/questions/286629/what-is-a-memory-fence)
            - Memory ordering is crucial
                - Порядок операций с памятью в системе по умолчанию очень расслаблен, и ЦП имеет большую свободу
                  переупорядочивать операции, и компиляторы также могут располагать инструкции, которые он выдает, в
                  любом порядке, который им нравится, при условии, что это не влияет на очевидную работу программы.
                - В многопоточном сценарии, чтобы избежать условий гонки, следует применять порядок доступа из разных
                  потоков.
                - (i) Ограниченные гарантии ЦП
                  на любом ЦП зависимые обращения к памяти будут выполняться по порядку;
                  перекрывающиеся загрузки и сохранения внутри определенного ЦП будут казаться упорядоченными внутри
                  этого ЦП;
                  перекрывающиеся обращения к памяти могут быть объединены или отброшены.
                  (ii) преобразование кода
                  ЦП и другие устройства в системе могут использовать различные приемы для повышения производительности,
                  включая переупорядочивание, отсрочку и комбинацию операций с памятью; спекулятивные нагрузки;
                  спекулятивное предсказание переходов и различные виды кэширования.
                - оптимизация компилятора
                  что знает компилятор
                  --> все операции с памятью в этом потоке и что именно они делают, включая зависимости данных;
                  --> как быть достаточно консервативным перед лицом псевдонимов psbl
                  что не знает
                  --> какие ячейки памяти являются "изменяемыми общими" переменными и могут изменяться асинхронно из-за
                  операции с памятью
                  в другом потоке
                  --> как быть достаточно консервативным перед лицом совместного использования psbl
                  решение: скажите --> каким-то образом определите операции над "изменяемыми общими" локациями
                  Независимые операции с памятью эффективно выполняются в случайном порядке, но это может быть проблемой
                  для
                  взаимодействия CPU-CPU и для ввода-вывода, и, следовательно, нам нужен порядок.
                - (iii) заказ является контрактом
                  Вы обещаете: правильно синхронизировать вашу программу (без условий гонки)
                  «Система» обещает: обеспечить иллюзию выполнения написанной вами программы
            - Ordering techniques
                - Чтобы гарантировать SC, вы должны подумать, как предотвратить переупорядочивание памяти. Пути могут
                  быть облегченной синхронизацией или ограждением , полным ограждением или семантикой
                  приобретения/освобождения .
                - Хранилище выпуска делает свои предыдущие доступы видимыми для потока, выполняющего загрузку, который
                  видит (сопряжение) с этим хранилищем .
                - Автоматизация получения и выпуска:
                  --> не пишите заборы вручную.
                  --> заставьте компилятор писать барьеры для вас, используя абстракции «критической области»: мьютексы
                  и переменные std::
                  atomic<> .
                - (i) #1: используйте мьютексы
                  используйте блокировки мьютекса для защиты кода, который читает/записывает общие переменные.
                  Плюсы:
                  Минусы: требует осторожности при каждом использовании общих переменных.
                - ```c++
                  //Lock acquire/release:
                  mut_x.lock(); //"acquire" mut_x ==> ld.acq mut_x
                  ... read/write x ...
                  mut_x.unlock(); //"release" mut_x ==> st.rel mut_x
                  ```
                - (ii) #2: std::atomic<>
                  специальные атомарные типы автоматически защищены от переупорядочения.
                  Плюсы: просто пометьте переменную, а не везде, где она используется. Минусы: написать правильный
                  атомарный код сложнее, чем кажется.
                - ```c++
                  std::atomics: read=acquire, write=release
                  while(whose_turn != me){} //read whose_turn ==> ld.acq whose_turn
                  ... read/write x ...
                  whose_turn = someone_else; //write whose_turn ==> st.rel whose_turn
                  ```
                - (iii) #3: заборы и заказанные API
                  Ограждение/барьер памяти — это класс инструкций, обеспечивающих загрузку/сохранение памяти в ожидаемом
                  порядке. В
                  отличие от мьютексов высокого уровня и атомарных объектов, ограничения памяти зависят от аппаратного
                  обеспечения.

                - Свободное от
                    - блокировок программирование Свободная от блокировок программа никогда не может быть полностью
                      остановлена ​​ни одним
                      потоком. Полная «блокировка» может быть любой, например, тупиковой, живой или даже злонамеренной
                      диспетчерской.

                - [1. Последовательная согласованность](http://preshing.com/20120612/an-introduction-to-lock-free-programming/#sequential-consistency)
                - [2. Блокировка свободного программирования](http://stackoverflow.com/questions/14011849/lock-free-multithreaded-programming)
                - [3. Получение и освобождение семантики](http://preshing.com/20120913/acquire-and-release-semantics/)
            - Object layout
                - Все данные в программе C++ состоят из объектов , каждый из которых представляет собой «область
                  хранения».
                  Объекты могут быть простого фундаментального типа, такого как int или float , а также могут быть
                  экземплярами определяемых пользователем классов.
                  Независимо от типа объект хранится в одной или нескольких ячейках памяти . Каждая такая ячейка памяти
                  является либо объектом (или подобъектом) скалярного типа, например, short или my_class* , либо
                  последовательностью смежных.
                - Каждая переменная является объектом, включая те, которые являются членами других объектов.
                  Каждый объект занимает как минимум одну ячейку памяти.
                  Переменные фундаментального типа (например, int или char ) представляют собой точно одну ячейку
                  памяти, независимо от их размера, даже если они являются смежными или являются частью массива.
                  Смежные битовые поля являются частью одной и той же ячейки памяти.
                  Учитывая две глобальные переменные char c и char d :
                - ```c++
                  //Thread 1
                  { lock_guard<mutex> lock(cMutex);
                      c = 1;
                  }
                  //Thread 2
                  { lock_guard<mutex> lock(dMutex);
                      d = 1;
                  }
                  ```
                - В идеальном C++11 нет расы, но в реальной жизни это psbl (например, и смежные битовые поля как один
                  объект):
                - ```c++
                  //system lays out c then d contiguously
                  char tmp[4]; //32-bit scratchpad
                  memcpy(&tmp[0], &c, 4); //read 32b starting at c
                  tmp[1] = 1; //set only bits of d
                  memcpy(&c, &temp[0], 4); //write 32 bits back
                  //thread 2 sliently also write to c without holding cMutex
                  ```
              [1. Битовое поле](http://en.cppreference.com/w/cpp/language/bit_field)
              [2. Ложное совместное использование](https://software.intel.com/en-us/articles/avoiding-and-identifying-false-sharing-among-threads)
                - Спекуляция и размещение реестра
                    - предположение:
                      система (компилятор, ЦП, кеш, ...) предполагает, что условие может быть истинным (например,
                      предсказание ветвления),
                      или имеет основания полагать, что условие часто верно (например, оно было истинным последние 100
                      раз). мы выполнили
                      этот код)
                      Чтобы сэкономить время, мы можем оптимистично начать дальнейшее выполнение, основываясь на этом
                      предположении. Если
                      это правильно, мы сэкономили время. Если это неправильно, мы должны отменить любую спекулятивную
                      работу.
                    - ```c++
                      if(cond)    | {
                           lock x | unique_lock<mutex> hold(mut, defer_lock)
                              ... | if(cond)
                      if(cond)    | hold.lock();
                            use x | ...
                              ... | if(cond)
                      if(cond)    | use x
                         unlock x | ...
                                  | }//as-if "if(cond) hold.unlock()"
                      ```
                    - Приведенный выше общий шаблон безопасен для MM C++11. Но остерегайтесь ошибок компилятора...
                    - ```c++
                      //x is a shared var
                      if(cond)
                      x = 42;
                      //cond is speculated to be true, rewrite code
                      r1 = x; //read what's there
                      x = 42; //oops: optimistic write is NOT conditional
                      if(!cond) //check if we guessed wrong
                      x = r1; //oops: back-out write is NOT sc
                - размещение регистра
                - условные блокировки :
                  --> Проблема: ваш код использует блокировку по условию, но в вашей системе есть ошибка , которая
                  изменяет условную
                  запись на безусловную.
            - C++11 techniques
                - (i) std::lock_guard
                  Класс lock_guard — это оболочка мьютекса, предоставляющая удобный механизм в стиле RAII для владения
                  мьютексом на время действия блока с областью действия.
                  Когда создается объект защиты блокировки, он пытается завладеть предоставленным ему мьютексом. Когда
                  управление покидает область, в которой был создан объект защиты блокировки, блокировка_защиты
                  разрушается, а мьютекс освобождается.
                - ```c++
                  #include <thread>
                  #include <mutex>
                  #include <iostream>
    
                  int g_i = 0;
                  std::mutex g_i_mutex; //protects g_i
    
                  void safe_incremenet(){
                      std::lock_guard<std::mutex> lock(g_i_mutex);
                      ++g_i;
                      std::cout << std::this_thread::get_id() << ":" << g_i << '\n';
     
                      //g_i_mutex is automically released when lock goes out of scope
                  }
    
                  int main(){
                      std::cout << __func__ << ": " << g_i << '\n';
                      std::thread t1(safe_increment);
                      std::thread t2(safe_increment); 
                      t1.join();
                      t2.join(); 
                      std::cout << __func__ << ": " << g_i << '\n';
                  }
                  ```
                - (ii) Используйте std::atomic для параллелизма
                  Экземпляры шаблона std::atomic предлагают операции, которые гарантированно будут восприниматься
                  другими потоками как атомарные . После создания объекта std::atomic операции над ним ведут себя так,
                  как если бы они находились внутри критической секции, защищенной мьютексом, но операции обычно
                  реализуются с использованием специальных машинных инструкций, которые более эффективны, чем в случае,
                  если бы мьютекс был занят.
                - ```c++
                  std::atomic<int> ai(0); //init ai to 0
                  ai = 10; //atomically set ai to 10
                  std::cout << ai; //atomically read ai's value
                  ++ai; //atomically increment ai to 11
                  --ai; //atomically decrement ai to 10
                  ```
                - Во время выполнения этих операторов другие потоки, читающие ai, могут видеть только значения 0, 10 или
                  11 . Никакие
                  другие значения невозможны (предположим, что это единственный поток, изменяющий ai).
                - std::atomic гарантирует только то, что чтение ai является атомарным, но не гарантирует, что весь
                  оператор будет
                  выполняться атомарно.
                - Между моментом чтения значения ai и вызовом оператора << для записи в стандартный вывод другой поток
                  мог изменить
                  значение ai.
                - после создания объекта std::atomic все его функции-члены, в том числе содержащие операции RMW,
                  гарантированно будут
                  восприниматься другими потоками как атомарные.
            - (iii) Непереносимые функции по своей сути
              Для поддержки низкоуровневого программирования C++ определяет некоторые функции, зависящие от машины.
                - Битовые поля
                  Битовое поле содержит определенное количество битов, а структура памяти битового поля зависит от
                  машины.
                - volatile
                  Ключевое слово volatile указывает компилятору, что он не должен выполнять оптимизацию таких объектов.
            - потоки С++
                - (1) Управление потоками
                - (i) базовое управление
                  detach thread
                  отсоединяет поток, представленный объектом, от вызывающего потока, позволяя им выполняться независимо
                  друг от друга.
                  Оба потока продолжают работать без блокировки и синхронизации.
                  Когда любой из них завершает выполнение, его ресурсы освобождаются.

                - Вызов detach() для объекта потока оставляет поток работать в фоновом режиме, и к нему больше нельзя
                  присоединиться.

                - join thread
                  Функция возвращается после завершения выполнения потока.

                - передача владения потоком std::thread t2=std::move(t1)

                - [1 Отделение нити](http://www.cplusplus.com/reference/thread/thread/detach/)
                - [2 Соединение нити](http://www.cplusplus.com/reference/thread/thread/join/)
                - ```c++
                  //compile: -std=c++0x -pthread
                  //the func we want to execute on the new thread
                  void task1(string msg){
                      cout << "task1 says: " << msg;
                  }

                  int main(){
                      //constructs the new thread and runs it
                      //form: thread(Function&& f, Args&&... args);
                      thread t1(task1, "Hello");

                      //makes the main thread wait for the new thread to finish, then continue
                      t1.join();
                  }
                  ```
                - ```c++
                  void pause_thread(int n){
                      std::this_thread::sleep_for (std::chrono::seconds(n));
                      std::cout << "pause of " << n << " seconds ended\n";
                  }

                  int main(){
                      std::cout << "spawning and detaching 3 threads ...\n";
                      std::thread(pause_thread, 1).detach();
                      std::thread(pause_thread, 2).detach();
                      std::thread(pause_thread, 3).detach();

                      std::cout << "Done spawning thread.\n";
                      //give the detached threads time to finish, but no guarantee
                      pause_thread(5);
                      return 0;
                  }
                  ```
    </details>

  ---

  #### 6. Что такое сериализация? Какие библиотеки знаете?

    - <details><summary>Ответ:</summary>

        - [Сериализация](https://habr.com/ru/post/479462/) — процесс перевода структуры данных в последовательность
          байтов. Обратной к операции сериализации
          является операция десериализации — создание структуры данных из битовой последовательности. Сериализация
          используется для передачи объектов по сети и для сохранения их в файлы.

    </details>

  ---

  #### 7. Какие знаете паттерны проектирования?

    - <details><summary>Ответ:</summary>

        - Ссылка на [материал](https://cpphinditutorials.com/dev-cpp/16-basic-patterns-programs-in-cpp/)
        - [GoF](http://www.dre.vanderbilt.edu/~schmidt/qualcomm/GoF-patterns.html)
    </details>

  ---  

  #### 8. Что такое операционная система? Какие существуют типы по назначению?

    - <details><summary>Ответ:</summary>

      OS [wiki](https://en.wikipedia.org/wiki/Operating_system)
    </details>

  --- 

  #### 9. Назвать основные составляющие и принципы работы ОС Linux в качестве примера системы общего назначения.

    - <details><summary>Ответ:</summary>

      5 основных принципов безопасности системы Linux
      До сих пор часто люди не знают, с чего начать, когда дело доходит до информационной безопасности. С помощью 5
      основных принципов мы можем улучшить безопасность системы Linux и задаться вопросом, достаточно ли мы сделали.

        1. Знайте свою систему (системы)
           Первый принцип заключается в том, чтобы знать, что должна делать ваша система. Какова его основная роль,
           какие
           программные пакеты ему нужны и кому нужен доступ?
           Зная роль системы, вы сможете лучше защитить ее от известных и неизвестных угроз.
           ##### Меры безопасности:
            - Политика паролей
            - Надлежащее управление исправлениями программного обеспечения
            - Управление конфигурацией
            - Документация
        2. Наименьшее количество привилегий
           Каждый запущенный процесс или установленный пакет может стать целью. Специалисты по безопасности называют это
           «поверхностью атаки». Что вам нужно, так это свести к минимуму эту поверхность атаки, удалив ненужные
           компоненты,
           ограничив доступ и по умолчанию используя стратегию «запретить, если только». Последнее означает, что доступ
           по
           умолчанию заблокирован, если вы его не разрешите (внесение в белый список).
           ##### Меры безопасности:
            - Использовать минимальную/базовую установку
              Разрешайте доступ только тем, кто действительно в этом нуждается
        3. Выполняйте глубокую защиту,
           защитите систему, применяя несколько уровней безопасности. Этот принцип называется «защита в глубину» и его
           можно
           сравнить с луковицей: чтобы добраться до сердцевины, нужно чистить слой за слоем. Одна сломанная защита может
           помочь
           нам защититься от полной компрометации.
           ##### Меры безопасности:
            - IP-таблицы/Nftables
            - Усиление программных компонентов
        4. Защита — это ключ, обнаружение — необходимость
           Безопасность фокусируется на защите активов. Хотя это основная цель, мы должны учитывать, что однажды наша
           защита
           будет сломана. Поэтому мы хотим узнать это как можно скорее, чтобы мы могли правильно действовать. Здесь
           связаны оба
           принципа 3 и 4. Установите надлежащие методы обнаружения, подобные растяжкам, используемым военными.
           ##### Меры безопасности:
            - Фреймворк аудита Linux
            - Удаленное ведение журнала
            - Создавайте резервные копии и тестируйте их
        5. Знай своего врага
           Вы можете правильно защитить систему только в том случае, если знаете, с какими угрозами вы сталкиваетесь.
           Почему эта
           система должна быть целью и кто будет нацеливаться на нее? Проведите анализ рисков и определите, каким
           потенциальным
           угрозам может подвергнуться ваша система.
           ##### Меры безопасности:
            - Сканирование уязвимостей
            - Тесты на проникновение
            - Анализ риска

        - [materials](https://slidetodoc.com/the-linux-system-design-principles-design-principles-linux/)
    </details>

  ---

  #### 10 Что такое SFINAE и PIMPL?

    - <details><summary>Ответ:</summary>

        - SFINAE
            - SFINAE расшифровывается как Substitution Failure Is Not An Error . _ _ _ Плохо сформированный код,
              возникающий в результате подстановки типов (или значений) для создания экземпляра шаблона функции или
              шаблона класса, не является серьезной ошибкой компиляции, он рассматривается только как ошибка вывода.
            - Неудачи вывода при создании экземпляров шаблонов функций или специализаций шаблонов классов удаляют этого
              кандидата из множества рассматриваемых, как если бы этот неудачный кандидат не существовал с самого
              начала.
            - ```c++
              template <class T>
              auto begin(T& c) -> decltype(c.begin()) { return c.begin(); }
              template <class T, size_t N>
              T* begin(T (&arr)[N]) { return arr; } 
              int vals[10];
              begin(vals); // OK. The first function template substitution fails because
                           // vals.begin() is ill-formed. This is not an error! That function
                           // is just removed from consideration as a viable overload candidate,
                           // leaving us with the array overload.
              ```
            - Только ошибки замены в непосредственном контексте считаются ошибками дедукции, все остальные считаются
              серьезными ошибками.
            - ```c++
              template <class T>
              void add_one(T& val) { val += 1; }
              int i = 4;
              add_one(i); // ok
              std::string msg = "Hello";
              add_one(msg); // error. msg += 1 is ill-formed for std::string, but this
                            // failure is NOT in the immediate context of substituting T
              ```
        - PIMPLS
            - Когда в заголовочный файл вносятся изменения, все исходники, включая его, необходимо перекомпилировать. В
              больших проектах и библиотеках это может вызвать проблемы со временем сборки из-за того, что даже при
              внесении небольшого изменения в реализацию всем приходится ждать некоторое время, пока они не скомпилируют
              свой код. Один из способов решить эту проблему — использовать PImpl Idiom, который скрывает реализацию в
              заголовках и включает файл интерфейса, который компилируется мгновенно.
            - Идиома PImpl (указатель на IMPLementation) — это метод, используемый для отделения реализации от
              интерфейса. Он сводит к минимуму раскрытие заголовков и помогает программистам уменьшить количество
              зависимостей при сборке за счет перемещения закрытых данных-членов в отдельный класс и доступа к ним через
              непрозрачный указатель.
            - <img src="Images/middle/img_10_1.png">
            - Как реализовать:
                1. Создайте отдельный класс (или структуру) для реализации
                2. Поместите все частные члены из заголовка в этот класс.
                3. Определите класс реализации (Impl) в файле заголовка.
                4. В заголовочном файле создайте предварительное объявление (указатель) , указывающее на класс
                   реализации.
                5. Определите деструктор и операторы копирования /присваивания .
            - Причина явного объявления деструктора заключается в том, что при компиляции интеллектуальный указатель (
              std::unique_ptr ) проверяет, существует ли в определении типа видимый деструктор, и выдает ошибку
              компиляции, если он объявлен только вперед.
            - Использование интеллектуального указателя является лучшим подходом, поскольку указатель берет на себя
              управление жизненным циклом PImpl.

            - ##### Пример:
                - Определение класса во включенном заголовочном файле является общедоступным интерфейсом класса.
                - Мы определяем уникальный указатель вместо необработанного, поскольку за время жизни объекта отвечает
                  объект интерфейсного типа.
                - Поскольку std::unique_ptr является полным типом, для завершения класса реализации требуется
                  объявленный пользователем деструктор и операторы копирования/присваивания.
                - Подход pimpl прозрачен с точки зрения пользователя. Внутренние изменения, внесенные в структуру
                  IMPLementation, влияют только на содержащий ее файл (User.cpp) . Это означает, что пользователю не
                  нужно перекомпилировать, чтобы применить эти изменения.
                - <details><summary>Header</summary>

                  ```c++
                  /* |INTERFACE| User.h file */

                  #pragma once
                  #include <memory> // PImpl
                  #include <string>
                  using namespace std;

                  class User {
                  public:
                  // Constructor and Destructors
                      ~User();
                      User(string name);
                      // Assignment Operator and Copy Constructor
                      User(const User& other);
                      User& operator=(User rhs);
                      // Getter
                      int getSalary();
                      // Setter
                      void setSalary(int);
                  private:
                  // Internal implementation class
                  class Impl;
                  // Pointer to the internal implementation
                  unique_ptr<Impl> pimpl;
                  };
                  ```
                </details>

                - <details><summary>Source</summary>

                    ```c++
                    /* |IMPLEMENTATION| User.cpp file */
                    #include "User.h"
                    #include <iostream>
                    using namespace std;
                    struct User::Impl {
                        Impl(string name) : name(move(name)){};
                        ~Impl();
                        void welcomeMessage()
                        {
                            cout << "Welcome, " << name << endl;
                        }
                        string name;
                        int salary = -1;
                        };
                        // Constructor connected with our Impl structure
                        User::User(string name) : pimpl(new Impl(move(name)))
                        {
                            pimpl->welcomeMessage();
                        }
                        // Default Constructor
                        User::~User() = default;
                        // Assignment operator and Copy constructor
                        User::User(const User& other) : pimpl(new Impl(*other.pimpl))
                        {
                        }
                        User& User::operator=(User rhs)
                        {
                            swap(pimpl, rhs.pimpl);
                            return *this;
                        }
                        // Getter and setter
                        int User::getSalary()
                        {
                            return pimpl->salary;
                        }
                        void User::setSalary(int salary)
                        {
                            pimpl->salary = salary;
                            cout << "Salary set to "
                                << salary << endl;
                        }
                    ```
                </details>
            - Преимущества PIMPl:
              Двоичная совместимость : двоичный интерфейс не зависит от приватных полей. Внесение изменений в реализацию
              не нарушит зависимый код.
              Время компиляции : время компиляции сокращается из-за того, что нужно пересобирать только файл реализации
              вместо того, чтобы каждый клиент перекомпилировал свой файл.
              Скрытие данных : можно легко скрыть определенные внутренние детали, такие как методы реализации и другие
              библиотеки, используемые для реализации общедоступного интерфейса.
              Недостатки PImpl:

            - Управление памятью : возможное увеличение использования памяти из-за большего выделения памяти, чем со
              структурой по
              умолчанию, что может иметь решающее значение при разработке встроенного программного обеспечения.
              Усилия по обслуживанию : обслуживание становится более сложным из-за дополнительного класса для
              использования pimpl и
              дополнительной косвенности указателя (Интерфейс можно использовать только через указатель/ссылку) .
              Наследование : Скрытая реализация не может быть унаследована, хотя класс PImpl может.

    </details>